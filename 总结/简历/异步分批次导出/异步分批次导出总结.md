# 异步分批次Excel导出功能详解

## 当前分析
1. ✅ 异步解耦
使用 CompletableFuture.runAsync() 实现异步处理
通过导出中心创建任务（任务 ID 不通过接口返回，用户可在「导出中心」查看进度与下载）
用户不需要阻塞等待
2. ✅ 流式写入
使用 EasyExcel 的流式写入方式
分页查询数据，避免一次性加载所有数据到内存
3. ✅ 云端存储
文件上传到文件服务器（baseCommonRpcApi.uploadFile）
通过文件ID提供下载链接

## 概述

ExportHelper是一个功能强大的Excel导出工具类，提供了同步和异步的Excel导出功能，支持大数据量分批次导出、多Sheet页导出、模板导出等多种场景。该工具基于EasyExcel框架实现，具有高性能、低内存占用的特点。

## 核心功能

### 1. 异步分批次导出 (asyncExportExcel)

异步分批次导出是该工具的核心功能，专门用于处理大数据量的Excel导出场景。


#### 1.2 核心特性

- **异步执行**: 使用CompletableFuture异步执行导出任务，不阻塞主线程
- **分批查询**: 支持分页查询，默认每页500条记录，避免内存溢出
- **自动分Sheet**: 单个Sheet最大支持100万行数据，超过自动创建新Sheet
- **导出中心集成**: 与导出中心系统集成，支持导出任务状态跟踪
- **文件上传**: 导出完成后自动上传到文件服务器
- **异常处理**: 完善的异常处理和错误信息记录


### 2. 关键组件

#### 2.1 ExportPageHandler接口

```java
@FunctionalInterface
public interface ExportPageHandler<T> {
    PageResultVO<T> page();
}
```

这是一个函数式接口，用于定义分页查询逻辑。使用者需要实现该接口来提供具体的数据查询方法。

#### 2.2 ExcelModelEntity实体

Excel模型实体类，包含导出Excel所需的所有配置信息：

- `taskType`: 导出任务类型
- `fileName`: 文件名
- `sheetName`: Sheet名称
- `headList`: 表头列表
- `widthList`: 列宽列表
- `titleHeight`: 表头高度
- `contentHeight`: 内容高度
- `excludeFieldList`: 排除字段列表
- `secondSheetList`: 第二个Sheet数据

#### 2.3 注解配置

**@ExcelModel注解**
- 用于类级别，定义Excel文件的基本信息
- 支持中英文双语配置
- 可配置文件名、Sheet名、列宽、高度等

**@ExcelColumn注解**
- 用于字段级别，定义Excel列的详细配置
- 支持标题、示例、格式化、对齐方式等配置
- 支持字段排序和过滤

### 3. 核心算法

#### 3.1 分批处理算法

```java
private static <T> void queryAndWrite(ExcelWriter writer, ExcelModelEntity entity, ExportPageHandler<T> handler, PageQuery query) {
    // 每一个工作簿可写入的数据量，需要把表头所占的行算上
    long sheetTotal = 1;
    // 工作簿编号
    int sheetNum = 1;
    // 页码
    int pageIndex = 1;
    query.setPageIndex(pageIndex);
    // 分页条数
    query.setPageSize(query.getExportPageSize() == null ? DEFAULT_PAGE_SIZE : query.getExportPageSize());
    // 不查询 Count
    query.setSearchCount(false);

    WriteSheet writeSheet = EasyExcel.writerSheet(entity.getSheetName())
            .registerWriteHandler(new ExcelCellStyleStrategy(entity.getAlignmentList()))
            .registerWriteHandler(new WidthStyleStrategy(entity.getWidthList()))
            .registerWriteHandler(new SimpleRowHeightStyleStrategy((short) entity.getTitleHeight(), (short) entity.getContentHeight()))
            .head(entity.getHeadList()).build();

    do {
        PageResultVO<T> pageResult = handler.page();
        List<T> list = pageResult.getRows();
        writer.write(getDataList(list, entity.getExcludeFieldList()), writeSheet);
        if (list.isEmpty()) {
            break;
        }

        // 条数大于Excel Sheet最大行数时，增加新的Sheet
        sheetTotal += list.size();
        if (sheetTotal >= SHEET_MAX) {
            sheetNum++;
            writeSheet = EasyExcel.writerSheet(entity.getSheetName() + "-" + sheetNum).head(entity.getHeadList()).build();
            sheetTotal = 1;
        }

        if (list.size() < query.getPageSize()) {
            // 查询结果数据量小于分页数量，处理结束
            break;
        }

        // 页码 + 1
        query.setPageIndex(++pageIndex);
    } while (true);
}
```

#### 3.2 数据转换算法

```java
private static <T> List<List<Object>> getDataList(List<T> list, List<String> excludeFieldList) {
    List<List<Object>> dataList = new ArrayList<>();
    if (CollectionUtils.isEmpty(list)) {
        return dataList;
    }
    Class<?> clazz = list.get(0).getClass();
    List<Field> fieldList = extractSortFields(clazz.getDeclaredFields(), excludeFieldList, null);
    list.forEach(t -> {
        ExcelColumn excelColumn;
        List<Object> dList = new ArrayList<>();
        for (Field field : fieldList) {
            excelColumn = field.getAnnotation(ExcelColumn.class);
            try {
                field.setAccessible(true);
                Object o = field.get(t);
                dList.add(getFieldValue(field, excelColumn, o));
            } catch (IllegalAccessException e) {
                dList.add("");
            }
        }
        dataList.add(dList);
    });
    return dataList;
}
```

### 4. 配置参数

#### 4.1 系统配置

- **SHEET_MAX**: 单个Sheet最大行数限制，默认100万行
- **DEFAULT_PAGE_SIZE**: 默认分页大小，默认500条
- **TEMP_DIR_PATH**: 临时文件存储路径

#### 4.2 依赖组件

- **ThreadPoolTaskExecutor**: 异步任务执行线程池
- **BaseCommonRpcApi**: 导出中心RPC接口
- **EasyExcel**: Excel读写框架

### 5. 使用示例

#### 5.1 基本用法

```java
// 定义数据模型
@ExcelModel(taskType = "USER_EXPORT", fileName = "用户数据导出", sheetName = "用户列表")
public class UserExportVO {
    @ExcelColumn(title = "用户ID", index = 1)
    private Long userId;
    
    @ExcelColumn(title = "用户名", index = 2, width = 20)
    private String userName;
    
    @ExcelColumn(title = "创建时间", index = 3, dateTimeFormat = "yyyy-MM-dd HH:mm:ss")
    private Date createTime;
}

// 实现分页查询处理器
ExportPageHandler<UserExportVO> handler = () -> {
    // 这里实现具体的分页查询逻辑
    return userService.pageQuery(query);
};

// 调用异步导出
PageQuery query = new PageQuery();
query.setPageIndex(1);
query.setPageSize(500);
ExportHelper.asyncExportExcel(UserExportVO.class, handler, query);
```

#### 5.2 高级用法

```java
// 排除某些字段
List<String> excludeFields = Arrays.asList("password", "salt");

// 添加第二个Sheet页数据
List<DeptExportVO> deptList = deptService.getAllDepts();

// 异步导出（包含排除字段和多Sheet）
ExportHelper.asyncExportExcel(UserExportVO.class, handler, query, excludeFields, deptList);
```

### 6. 性能优化

#### 6.1 内存优化

- 使用分页查询，避免一次性加载大量数据
- EasyExcel流式写入，降低内存占用
- 及时释放临时文件资源

#### 6.2 并发优化

- 异步执行，不阻塞主线程
- 使用线程池管理异步任务
- 支持多个导出任务并发执行

#### 6.3 存储优化

- 临时文件存储在指定目录
- 导出完成后自动上传到文件服务器
- 支持文件压缩和格式优化

### 7. 异常处理

#### 7.1 异常类型

- **数据查询异常**: 分页查询失败时的处理
- **文件写入异常**: Excel文件创建或写入失败
- **文件上传异常**: 文件上传到服务器失败
- **任务状态更新异常**: 导出记录状态更新失败

#### 7.2 异常处理策略

```java
private static <T> void executeAsyncExport(ExportPageHandler<T> handler, PageQuery query, ExcelModelEntity entity, long exportRecordId) {
    String fileId = null;
    String errorMsg = "success";
    try {
        // 导出并上传文件
        fileId = exportAndUploadExcel(entity, handler, query);
        if (StringUtils.isBlank(fileId)) {
            errorMsg = "Failed";
        }
    } catch (Exception e) {
        log.error("Export excel error", e);
        errorMsg = e.getMessage();
        if (errorMsg.length() > 500) {
            errorMsg = errorMsg.substring(0, 500);
        }
    } finally {
        // 更新导出记录
        updateExportRecord(entity, exportRecordId, fileId, errorMsg);
    }
}
```

### 8. 扩展功能

#### 8.1 模板导出

支持Excel模板导出，包含样例数据和说明信息：

```java
public static <T> void asyncExportTemplate(Class<T> clazz, List<T> dataList)
public static <T> void exportTemplate(HttpServletResponse response, Class<T> clazz)
```

#### 8.2 批量导出

支持多个Sheet页的批量导出：

```java
public static <T> void asyncBatchExportExcel(Class<T> firstClazz, List<T> firstList, List<?>... secondSheetList)
```

#### 8.3 图片导出

支持将Excel转换为图片格式：

```java
public static void excel2Image(File excel, String imageName)
public static void exportImage(String imageName, LinkedHashMap<String, List<?>> tableMap)
```

### 9. 最佳实践

#### 9.1 数据模型设计

- 使用@ExcelModel和@ExcelColumn注解进行配置
- 合理设置字段顺序和列宽
- 支持中英文双语配置

#### 9.2 分页查询优化

- 合理设置分页大小，平衡内存和性能
- 使用索引优化查询性能
- 避免在分页查询中使用复杂的关联查询

#### 9.3 异常监控

- 记录详细的异常日志
- 监控导出任务的成功率和耗时
- 及时清理临时文件

### 10. 技术架构

#### 10.1 技术栈

- **Spring Boot 2.3.4**: 基础框架
- **EasyExcel**: Excel读写框架
- **MyBatis-Plus**: ORM框架
- **CompletableFuture**: 异步编程
- **Redisson 3.27.0**: 分布式锁和缓存

#### 10.2 设计模式

- **策略模式**: ExportPageHandler接口设计
- **模板方法模式**: 导出流程的统一模板
- **建造者模式**: ExcelWriter的构建
- **注解驱动**: 配置信息的声明式管理

### 11. 总结

ExportHelper异步分批次Excel导出功能是一个功能完善、性能优异的企业级导出解决方案。它具有以下优势：

1. **高性能**: 异步执行、分批处理、流式写入
2. **高可用**: 完善的异常处理和状态跟踪
3. **易扩展**: 注解驱动、接口化设计
4. **易使用**: 简洁的API设计和丰富的配置选项

该工具特别适用于大数据量的Excel导出场景，能够有效解决传统同步导出在处理大量数据时的性能瓶颈和内存溢出问题。