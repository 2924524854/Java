# 链路追踪实现总结

## 一、当前系统链路追踪实现

### 1.1 实现概述

当前系统采用**基于TraceId的简单链路追踪方案**，通过自定义Filter和ThreadLocal实现请求链路标识的生成和传递。

### 1.2 核心组件

#### 1.2.1 TraceIdFilter（请求入口过滤器）

**位置**：`corehrpt-basic/src/main/java/com/oppo/corehrpt/basic/logging/trace/TraceIdFilter.java`

**功能**：
- 从HTTP请求头中获取`corehr_trace_id`
- 如果请求头中没有traceId，则自动生成一个5位随机字符串
- 将traceId设置到`TraceIdContextHolder`和`MDC`中
- 在响应头中添加traceId
- 请求结束后清理ThreadLocal和MDC

**关键代码**：
```java
@Order(Ordered.LOWEST_PRECEDENCE - 10)
public class TraceIdFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) {
        String traceId = request.getHeader(TraceIdContextHolder.TRACE_TAG);
        if (StringUtils.isEmpty(traceId)) {
            traceId = generateTraceId(); // 生成5位随机字符串
        }
        TraceIdContextHolder.setTraceId(traceId);
        MDC.put(TraceIdContextHolder.TRACE_TAG, traceId);
        response.addHeader(TraceIdContextHolder.TRACE_TAG, traceId);
        // ...
    }
}
```

#### 1.2.2 TraceIdContextHolder（上下文持有者）

**位置**：`corehrpt-basic/src/main/java/com/oppo/corehrpt/basic/logging/trace/TraceIdContextHolder.java`

**功能**：
- 使用`ThreadLocal`存储当前线程的traceId
- 提供get/set/clear方法管理traceId

**关键代码**：
```java
public class TraceIdContextHolder {
    public static final String TRACE_TAG = "corehr_trace_id";
    private static final ThreadLocal<String> TRACE_ID_THREAD_LOCAL = new ThreadLocal<>();
    
    public static String getTraceId() {
        return TRACE_ID_THREAD_LOCAL.get();
    }
    
    public static void setTraceId(String traceId) {
        TRACE_ID_THREAD_LOCAL.set(traceId);
    }
    
    public static void clear() {
        TRACE_ID_THREAD_LOCAL.remove();
    }
}
```

#### 1.2.3 TraceIdFeignRequestInterceptor（Feign调用拦截器）

**位置**：`corehrpt-basic/src/main/java/com/oppo/corehrpt/basic/logging/trace/TraceIdFeignRequestInterceptor.java`

**功能**：
- 在Feign服务间调用时，自动将traceId添加到请求头中
- 实现服务间链路追踪的连续性

**关键代码**：
```java
public class TraceIdFeignRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate template) {
        if (TraceIdContextHolder.getTraceId() != null) {
            template.header(TraceIdContextHolder.TRACE_TAG, TraceIdContextHolder.getTraceId());
        }
    }
}
```

#### 1.2.4 WrappedThreadPoolTaskExecutor（线程池包装器）

**位置**：`corehrpt-basic/src/main/java/com/oppo/corehrpt/basic/logging/trace/WrappedThreadPoolTaskExecutor.java`

**功能**：
- 包装Spring的`ThreadPoolTaskExecutor`
- 在异步任务执行前，将父线程的traceId传递到子线程
- 在异步任务执行后，清理子线程的traceId
- 解决异步场景下traceId丢失的问题

**关键代码**：
```java
private Runnable wrapper(Runnable runnable) {
    String traceId = TraceIdContextHolder.getTraceId();
    return () -> {
        TraceIdContextHolder.setTraceId(traceId);
        MDC.put(TraceIdContextHolder.TRACE_TAG, traceId);
        try {
            runnable.run();
        } finally {
            TraceIdContextHolder.clear();
            MDC.remove(TraceIdContextHolder.TRACE_TAG);
        }
    };
}
```

#### 1.2.5 LoggingTraceAutoConfiguration（自动配置类）

**位置**：`corehrpt-basic/src/main/java/com/oppo/corehrpt/basic/logging/LoggingTraceAutoConfiguration.java`

**功能**：
- 通过`@ConditionalOnProperty`控制是否启用链路追踪
- 配置属性：`corehr.logging.trace.enable=true`
- 自动注册`TraceIdFilter`和`TraceIdFeignRequestInterceptor`

### 1.3 TraceId生成规则

**位置**：`corehrpt-basic/src/main/java/com/oppo/corehrpt/basic/util/RandomCodeUtil.java`

**生成方式**：
- 默认生成5位随机字符串
- 字符集：`23456789abcdefghjkmnopqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ`（排除易混淆字符）
- 使用`SecureRandom`保证随机性

**示例**：`7wZ2H`、`Db6qj`

### 1.4 日志集成

**配置位置**：`conf/service-shared.yml`

**日志格式**：
```yaml
logging:
  pattern:
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} %5p ${PID:} --- [%t] %X{corehr_trace_id} %-40.40logger{39} : %m%n%wEx"
    console: "%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(%5p) %clr(${PID:}){magenta} %clr(---){faint} %clr([%t]){faint} %X{corehr_trace_id} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n%wEx"
```

**说明**：
- 通过`%X{corehr_trace_id}`在日志中输出traceId
- 所有日志都会自动包含traceId，便于日志关联查询

**说明**：系统已准备好使用OpenTelemetry + Zipkin的完整链路追踪方案，但目前未启用。

### 1.6 当前方案的优缺点

#### 优点
1. **实现简单**：代码量少，易于理解和维护
2. **性能开销小**：仅使用ThreadLocal和MDC，无额外网络开销
3. **日志关联**：通过traceId可以快速关联同一请求的所有日志
4. **服务间传递**：通过Feign拦截器实现服务间traceId传递
5. **异步支持**：通过线程池包装器支持异步场景

#### 缺点
1. **功能单一**：仅提供traceId标识，无法展示完整的调用链
2. **无可视化**：没有UI界面展示调用链路图
3. **无性能分析**：无法统计各服务/方法的耗时
4. **无采样控制**：所有请求都会生成traceId，无法控制采样率
5. **无存储**：traceId仅存在于日志中，无法进行结构化查询和分析
6. **无告警**：无法基于链路数据设置告警规则
7. **手动排查**：需要手动通过grep等工具搜索日志，效率较低

---

## 二、市面上成熟的链路追踪技术

### 2.1 OpenTelemetry（推荐）

**简介**：CNCF（云原生计算基金会）的标准化项目，旨在统一可观测性标准。

**特点**：
- **标准化**：统一的API和SDK，支持多种语言
- **厂商无关**：可以导出到Zipkin、Jaeger、Prometheus等多种后端
- **自动埋点**：通过Java Agent实现零代码侵入
- **丰富生态**：支持多种框架和中间件（Spring、Dubbo、Redis、MySQL等）

**架构**：
```
应用代码 → OpenTelemetry SDK/Agent → Collector → 后端存储（Zipkin/Jaeger/SkyWalking等）
```

**Java集成方式**：
```bash
# 方式1：Java Agent（推荐，零代码侵入）
java -javaagent:opentelemetry-javaagent.jar \
     -Dotel.service.name=my-service \
     -Dotel.traces.exporter=zipkin \
     -Dotel.exporter.zipkin.endpoint=http://localhost:9411/api/v2/spans \
     -jar myapp.jar

# 方式2：SDK方式（需要代码改造）
```

**优势**：
- 行业标准，未来趋势
- 零代码侵入（Agent方式）
- 支持多种导出格式
- 社区活跃，持续更新

**适用场景**：
- 新建项目或需要统一可观测性标准
- 多语言技术栈
- 需要灵活的导出后端选择

---

### 2.2 Zipkin

**简介**：Twitter开源的分布式追踪系统，基于Google Dapper论文实现。

**特点**：
- **成熟稳定**：2012年开源，使用广泛
- **轻量级**：核心功能简单，易于部署
- **RESTful API**：提供标准的HTTP API
- **多种存储**：支持内存、MySQL、Elasticsearch、Cassandra等

**架构**：
```
应用 → Zipkin Client → Zipkin Collector → Storage → Zipkin UI
```

**Java集成方式**：
```xml
<!-- Maven依赖 -->
<dependency>
    <groupId>io.zipkin.zipkin2</groupId>
    <artifactId>zipkin</artifactId>
    <version>2.23.0</version>
</dependency>
<dependency>
    <groupId>io.zipkin.reporter2</groupId>
    <artifactId>zipkin-reporter-brave</artifactId>
    <version>2.16.3</version>
</dependency>
```

**Spring Boot集成**：
```yaml
# application.yml
spring:
  zipkin:
    base-url: http://localhost:9411
    sender:
      type: web
  sleuth:
    zipkin:
      base-url: http://localhost:9411
```

**优势**：
- 部署简单，上手快
- 社区成熟，文档完善
- 支持多种存储后端
- UI界面简洁直观

**劣势**：
- 功能相对简单，缺少APM能力
- 不支持指标和日志的统一管理
- Spring Cloud Sleuth已停止维护（推荐迁移到OpenTelemetry）

**适用场景**：
- 中小型项目
- 只需要基础的链路追踪功能
- 快速搭建和验证

---

### 2.3 Jaeger

**简介**：Uber开源的分布式追踪系统，CNCF毕业项目。

**特点**：
- **高性能**：使用Go语言开发，性能优秀
- **云原生**：原生支持Kubernetes部署
- **采样策略**：支持多种采样策略（固定采样率、自适应采样等）
- **多存储**：支持Cassandra、Elasticsearch、Kafka等

**架构**：
```
应用 → Jaeger Client → Agent → Collector → Storage → Query → UI
```

**Java集成方式**：
```xml
<!-- Maven依赖 -->
<dependency>
    <groupId>io.jaegertracing</groupId>
    <artifactId>jaeger-client</artifactId>
    <version>1.8.1</version>
</dependency>
```

**优势**：
- 性能优秀，适合大规模场景
- 采样策略灵活
- 云原生支持好
- 支持OpenTracing标准（已合并到OpenTelemetry）

**适用场景**：
- 大规模微服务架构
- 需要高性能和灵活的采样策略
- Kubernetes环境

---

### 2.4 SkyWalking

**简介**：Apache基金会顶级项目，国产开源APM系统。

**特点**：
- **APM能力**：不仅提供链路追踪，还包含性能监控、日志分析等
- **Java Agent**：通过字节码增强实现零代码侵入
- **中文支持**：中文文档完善，社区活跃
- **功能丰富**：支持服务拓扑、性能分析、告警等

**架构**：
```
应用 → SkyWalking Agent → OAP Server → Storage → UI
```

**Java集成方式**：
```bash
# 方式1：Java Agent（推荐）
java -javaagent:/path/to/skywalking-agent.jar \
     -DSW_AGENT_NAME=my-service \
     -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=localhost:11800 \
     -jar myapp.jar

# 方式2：SDK方式
```

**优势**：
- 功能全面，APM能力强大
- 零代码侵入（Agent方式）
- 中文文档完善
- 支持多种语言和框架
- 性能开销小

**劣势**：
- 主要面向Java生态
- 存储方案相对固定（ES/H2/MySQL等）

**适用场景**：
- Java技术栈为主
- 需要完整的APM能力
- 希望零代码侵入
- 国内团队，需要中文支持

---

### 2.5 Pinpoint

**简介**：Naver开源的APM工具，专注于Java应用。

**特点**：
- **字节码增强**：通过字节码注入实现无侵入监控
- **实时监控**：提供实时调用链和性能监控
- **功能全面**：包含链路追踪、性能分析、异常监控等

**架构**：
```
应用 → Pinpoint Agent → Collector → HBase → Web UI
```

**Java集成方式**：
```bash
java -javaagent:/path/to/pinpoint-agent/pinpoint-bootstrap.jar \
     -Dpinpoint.agentId=my-service \
     -Dpinpoint.applicationName=my-app \
     -jar myapp.jar
```

**优势**：
- 无侵入监控
- 功能全面
- 实时性能分析

**劣势**：
- 仅支持Java
- 存储依赖HBase，部署复杂
- 社区活跃度相对较低

**适用场景**：
- 纯Java技术栈
- 需要详细的性能分析
- 已有HBase基础设施

---

## 三、技术选型对比

| 特性 | OpenTelemetry | Zipkin | Jaeger | SkyWalking | Pinpoint |
|------|--------------|--------|--------|------------|----------|
| **标准化** | ????? | ??? | ???? | ??? | ?? |
| **零侵入** | ????? | ?? | ?? | ????? | ????? |
| **功能丰富度** | ???? | ?? | ??? | ????? | ???? |
| **性能** | ???? | ??? | ????? | ???? | ??? |
| **易用性** | ???? | ????? | ???? | ???? | ??? |
| **社区活跃度** | ????? | ??? | ???? | ????? | ?? |
| **中文支持** | ??? | ??? | ?? | ????? | ?? |
| **多语言支持** | ????? | ??? | ??? | ???? | ? |

---

## 四、推荐方案

### 4.1 短期方案（快速改进）

**方案**：在现有TraceId基础上，集成OpenTelemetry + Zipkin

**理由**：
1. 启动脚本中已有相关配置（只需取消注释）
2. 零代码侵入，通过Java Agent实现
3. 可以保留现有的TraceId机制
4. 快速获得可视化链路追踪能力

**实施步骤**：
1. 部署Zipkin服务
2. 在启动脚本中启用OpenTelemetry Agent配置
3. 配置采样率（建议0.1，即10%采样）
4. 验证链路追踪效果

### 4.2 长期方案（完整APM）

**方案**：迁移到SkyWalking

**理由**：
1. 功能全面，不仅链路追踪，还包含性能监控、告警等
2. 零代码侵入，通过Java Agent实现
3. 中文文档完善，适合国内团队
4. 社区活跃，持续更新
5. 性能开销小

**实施步骤**：
1. 部署SkyWalking OAP Server和UI
2. 配置Java Agent
3. 逐步迁移各服务
4. 配置告警规则
5. 建立监控看板

---

## 五、总结

### 5.1 当前系统状态

当前系统实现了**基础的TraceId追踪机制**，能够：
- ? 生成和传递traceId
- ? 在日志中输出traceId
- ? 支持服务间调用传递
- ? 支持异步场景

但缺少：
- ? 可视化调用链
- ? 性能分析能力
- ? 结构化存储和查询
- ? 告警能力

### 5.2 改进建议

1. **短期**：启用OpenTelemetry + Zipkin，快速获得可视化能力
2. **中期**：评估SkyWalking，考虑完整APM方案
3. **长期**：建立统一的可观测性平台，整合链路追踪、指标监控、日志分析

### 5.3 注意事项

1. **采样率**：生产环境建议设置采样率（如10%），避免性能影响
2. **存储成本**：链路数据量大，需要考虑存储成本
3. **性能影响**：虽然Agent方式性能影响小，但仍需监控
4. **数据保留**：制定数据保留策略，避免存储无限增长

---
解释这个文档的总结