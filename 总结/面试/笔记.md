# 1.RBAC权限控制

常见的RBAC权限表结构包括用户表（user）、角色表（role）、权限表（permission）、用户-角色关联表（user_role）、角色-权限关联表（role_permission）。
在实际业务系统中，为满足更加复杂和实际的业务需求，还会对这些表结构进行扩展和优化。下面介绍几种扩展方式和常见设计：

1. 加入"资源"或"对象"维度

   原始的权限通常只是简单的操作动作（如read、write），但在复杂场景下，常常需要细化到具体的"对象"或"资源"：

   - 资源表（resource）：如菜单、功能模块、部门、数据表等对象
   - 权限表结构增加资源维度：如列出资源类型和资源ID
   - 例子：`permission（id, action, resource_type, resource_id, description）`

2. 支持数据权限、组织权限

   有时要对不同组织、部门、团队下的数据粒度控制：

   - 部门表（department）、用户-部门表（user_department）
   - 角色-部门权限表（role_department_permission）
   - 可在权限表中增加"数据范围"字段，例如：本部门、本公司、全部数据、本人数据等

3. 多租户支持

   如果系统支持多租户（即SaaS），需要加入租户（tenant）相关的字段：

   - 在所有关联表中增加tenant_id字段
   - 如 `user（id, name, ..., tenant_id）`、`role（id, name, ..., tenant_id）`

4. 加入"角色组"或"权限组"

   便于批量赋权和管理：

   - 角色组表（role_group）
   - 角色-角色组表（role_role_group）
   - 权限组表（permission_group）
   - 权限-权限组表（permission_permission_group）

5. 用户-权限直接关联（直连、例外）

   有业务需要直接授权给某些用户特殊权限时，可以新增：

   - 用户-权限表（user_permission）

6. 操作日志——审计与回溯

   为满足合规和审计，需要记录权限变更操作：

   - 操作日志表（audit_log）：记录谁何时修改了什么权限、角色分配变化等

7. 接口与菜单权限

   权限可以细化到具体接口（如API或URL）和前端菜单/按钮：

   - 菜单表（menu）、接口表（api_endpoint）
   - 角色-菜单、角色-接口关联表

8. 角色层级或继承关系

   - 角色表增加 parent_id 字段实现角色继承
   - 角色树，用于支持RBAC1模型中的角色上下级关系

#### 数据权限、组织权限
一、数据权限
数据权限是指系统中对“数据范围”的访问控制。即限定用户能访问、查看、修改哪些具体的数据记录。

常见的数据权限类型
本人数据权限：只能查看或操作自己创建或分配到的数据。例如：员工只能查看自己填报的考勤记录。
本部门数据权限：可以访问本部门范围内的数据。例如：部门经理能查看本部门所有成员的考勤。
本公司数据权限：可操作公司所有部门的数据。例如：公司总经理能查看全公司考勤。
自定义数据权限：可以按规则灵活配置可访问的数据范围。
应用举例
OA系统审批单据：普通员工只能看到自己提交的单，部门主管能看到本部门所有单据。
CRM客户管理：销售只看自己跟进的客户，部门经理看本部门所有客户资料。
二、组织权限
组织权限是指系统中按“组织结构”划分访问或操作权限，比如公司、分公司、部门、项目组等层级。

具体表现
用户在系统中的角色或权限随着组织结构（如部门、公司、分公司、团队）变化而不同。
组织架构可以影响功能菜单、数据访问、操作权限等。
应用举例
公司总部与分公司：总部人员有权配置系统，分公司只能管理自己分公司内容。
部门专属功能：人事部可用人事管理功能，财务部可用财务报表功能，普通员工不能访问。


#### 本系统实现
数据权限：许可权、角色、人
组织权限: t_com_psoprd sec_opr, t_com_sjt_all sec_sjt
菜单权限：
1. 数据库表结构
菜单相关表
t_com_por_menu_hdr: 一级菜单头表
t_com_por_menu_sub1: 二级菜单表
t_com_por_menu_sub2: 三级菜单表
权限关联表
t_com_por_menu_sec: 一级菜单权限关联（菜单ID → 许可权）
t_com_por_menu_sec1: 二级菜单权限关联（菜单ID+子菜单ID → 许可权）
t_com_por_menu_sec2: 三级菜单权限关联（菜单ID+子菜单ID+叶子菜单ID → 许可权）
接口权限表
t_com_api_role: 接口权限配置表
2. 菜单权限控制实现
权限检查逻辑
每个层级的菜单都通过许可权进行权限控制：
```Java
-- 一级菜单权限检查
EXISTS (
    SELECT 'X' FROM t_com_por_menu_sec s, t_com_psrole_user u, t_com_psrole_class c
    WHERE s.fp_por_menu = t.fp_por_menu
    AND u.rolename = c.rolename
    AND u.roleuser = #{oprid}
    AND s.classid = c.classid
)

-- 二级菜单权限检查  
EXISTS (
    SELECT 'X' FROM t_com_por_menu_sec1 s, t_com_psrole_user u, t_com_psrole_class c
    WHERE s.fp_por_menu = t.fp_por_menu
    AND s.fp_por_submenu = t.fp_por_submenu
    AND s.classid = c.classid
    AND u.rolename = c.rolename
    AND u.roleuser = #{oprid}
)

-- 三级菜单权限检查
EXISTS (
    SELECT 'X' FROM t_com_por_menu_sec2 s, t_com_psrole_user u, t_com_psrole_class c
    WHERE s.fp_por_menu = t.fp_por_menu
    AND s.fp_por_submenu = t.fp_por_submenu  
    AND s.fp_por_leafmenu = t.fp_por_leafmenu
    AND s.classid = c.classid
    AND u.rolename = c.rolename
    AND u.roleuser = #{oprid}
)
```
3. 接口权限控制实现
接口权限配置 (ComApiRolePO)
```Java
@TableName("t_com_api_role")
public class ComApiRolePO {
    private String api;              // 接口路径
    private String linkId;           // 应用中心链接ID
    private String fpPorMenu;        // 一级菜单ID
    private String fpPorSubMenu;     // 二级菜单ID  
    private String fpPorLeafMenu;    // 三级菜单ID
}
```
接口权限检查 (ComApiRoleServiceImpl.hasApiRole)
```Java
public boolean hasApiRole(String emplid, String api) {
    // 1. 获取接口权限配置
    List<ComApiRolePO> apiRoleList = getApiRole(api);
    
    // 2. 检查应用中心权限
    if (linkList.contains(po.getLinkId())) {
        return true;
    }
    
    // 3. 检查菜单权限
    Map<String, Map<String, List<String>>> userMenu = getUserMenu(emplid);
    // 检查一级、二级、三级菜单权限
}
```


# 2.多线程插入大量数据

基于当前系统配置，实现多线程向`t_com_exec_assistant`表插入大量数据的功能。该功能采用多线程处理、数据分批、异常处理和进度监控等技术，确保大数据量插入的高效性和可靠性。

### 1. 多线程处理
- 专用线程池配置（corePoolSize: 8, maxPoolSize: 16）
- 支持并发批量插入，提高处理效率
- 队列容量1000，支持大批量任务排队

### 2. 数据分批处理
- 默认每批处理1000条记录
- 支持大数据量分批插入，避免内存溢出
- 智能数据分割和分配

### 3. 数据校验和预处理
- 业务单位+高管工号+助理工号唯一性校验
- 人员信息有效性校验（在职状态等）
- 自动填充人员姓名信息
- 重复数据跳过处理

### 4. 异常处理和事务管理
- 批次级别的异常处理
- 事务回滚保证数据一致性
- 详细的错误信息记录
- 支持部分失败场景的处理

### 5. 进度监控和状态跟踪
- 实时进度更新
- 成功/失败/跳过计数统计
- 处理耗时统计
- 异步任务状态查询

### 使用示例
```Java
/**
     * 多线程批量插入高管助理数据
     *
     * @param dataList 数据列表
     * @return 批量插入结果
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public ComExecAssistantBatchInsertVO batchInsert(List<ComExecAssistantPO> dataList) {
        if (CollUtil.isEmpty(dataList)) {
            throw new ServiceException("数据列表不能为空");
        }

        String taskId = IdUtil.fastSimpleUUID();
        ComExecAssistantBatchInsertVO result = new ComExecAssistantBatchInsertVO();
        result.setTaskId(taskId);
        result.setStatus("PROCESSING");
        result.setTotalCount(dataList.size());
        result.setSuccessCount(0);
        result.setFailedCount(0);
        result.setSkippedCount(0);
        result.setProgress(0.0);
        result.setStartTime(DateUtil.now());
        result.setErrorMessages(new ArrayList<>());
        result.setStatistics(new HashMap<>());

        try {
            // 数据预处理和校验
            List<ComExecAssistantPO> validDataList = preprocessData(dataList, result);

            if (CollUtil.isEmpty(validDataList)) {
                result.setStatus("COMPLETED");
                result.setEndTime(DateUtil.now());
                result.setDuration(System.currentTimeMillis() - DateUtil.parse(result.getStartTime()).getTime());
                return result;
            }

            // 多线程批量插入
            batchInsertMultithreaded(validDataList, result);

            result.setStatus("COMPLETED");
            result.setProgress(100.0);

        } catch (Exception e) {
            log.error("批量插入高管助理数据异常", e);
            result.setStatus("FAILED");
            result.getErrorMessages().add("批量插入失败: " + e.getMessage());
        }

        result.setEndTime(DateUtil.now());
        result.setDuration(System.currentTimeMillis() - DateUtil.parse(result.getStartTime()).getTime());

        return result;
    }

    /**
     * 异步批量插入高管助理数据
     *
     * @param dataList 数据列表
     * @return 任务ID
     */
    @Override
    @Async("batchInsertTaskExecutor")
    public String batchInsertAsync(List<ComExecAssistantPO> dataList) {
        String taskId = IdUtil.fastSimpleUUID();
        String redisKey = BATCH_TASK_PREFIX + taskId;

        // 初始化任务状态
        ComExecAssistantBatchInsertVO result = new ComExecAssistantBatchInsertVO();
        result.setTaskId(taskId);
        result.setStatus("PENDING");
        result.setTotalCount(dataList.size());
        result.setSuccessCount(0);
        result.setFailedCount(0);
        result.setSkippedCount(0);
        result.setProgress(0.0);
        result.setStartTime(DateUtil.now());
        result.setErrorMessages(new ArrayList<>());
        result.setStatistics(new HashMap<>());

        // 保存到Redis
        redisService.set(redisKey, result, 3600L); // 1小时过期

        try {
            // 执行批量插入
            ComExecAssistantBatchInsertVO finalResult = batchInsert(dataList);
            finalResult.setTaskId(taskId);
            redisService.set(redisKey, finalResult, 3600L);

        } catch (Exception e) {
            log.error("异步批量插入高管助理数据异常", e);
            result.setStatus("FAILED");
            result.getErrorMessages().add("异步批量插入失败: " + e.getMessage());
            redisService.set(redisKey, result, 3600L);
        }

        return taskId;
    }

    /**
     * 多线程批量插入
     *
     * @param dataList 数据列表
     * @param result   结果对象
     */
    private void batchInsertMultithreaded(List<ComExecAssistantPO> dataList,
                                         ComExecAssistantBatchInsertVO result) {
        // 分批处理
        List<List<ComExecAssistantPO>> batches = CollUtil.split(dataList, BATCH_SIZE);

        // 使用CompletableFuture进行并行处理
        List<CompletableFuture<Void>> futures = batches.stream()
                .map(batch -> CompletableFuture.runAsync(() -> {
                    try {
                        processBatch(batch, result);
                    } catch (Exception e) {
                        log.error("批量处理异常", e);
                        synchronized (result) {
                            result.getErrorMessages().add("批量处理异常: " + e.getMessage());
                        }
                    }
                }, batchInsertTaskExecutor))
                .collect(Collectors.toList());

        // 等待所有任务完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        // 更新进度
        result.setProgress(100.0);
    }

    /**
     * 处理单个批次
     *
     * @param batch  批次数据
     * @param result 结果对象
     */
    @Transactional(rollbackFor = Exception.class)
    private void processBatch(List<ComExecAssistantPO> batch, ComExecAssistantBatchInsertVO result) {
        if (CollUtil.isEmpty(batch)) {
            return;
        }

        try {
            // 批量保存
            try {
                this.saveBatch(batch);
                synchronized (result) {
                    result.setSuccessCount(result.getSuccessCount() + batch.size());
                }
            } catch (Exception e) {
                log.error("批次保存异常", e);
                synchronized (result) {
                    result.setFailedCount(result.getFailedCount() + batch.size());
                    result.getErrorMessages().add("批次保存失败，批次大小: " + batch.size() + ", 错误: " + e.getMessage());
                }
            }
        } catch (Exception e) {
            log.error("批次处理异常", e);
            synchronized (result) {
                result.setFailedCount(result.getFailedCount() + batch.size());
                result.getErrorMessages().add("批次处理异常: " + e.getMessage());
            }
        }
    }

```

## 配置说明

### 线程池配置
在`application-shared.yml`中添加：
```yaml
# 批量插入专用线程池参数
batch-insert-thread-pool:
  corePoolSize: 8
  maxPoolSize: 16
  queueCapacity: 1000
  keepAliveSeconds: 300
  allowCoreThreadTimeOut: false
  waitForJobsToCompleteOnShutdown: true
  awaitTerminationSeconds: 60
  rejectedExecutionHandler: CallerRunsPolicy
  threadGroupName: batch-insert-thread-pool
```

### 系统参数
- **BATCH_SIZE**: 每批处理记录数，默认1000
- **THREAD_POOL_SIZE**: 线程池大小，默认8
- **REDIS_KEY_EXPIRE**: 任务状态缓存过期时间，默认1小时

### 性能优化建议

1. **数据量评估**：
   - 小批量（<1000条）：直接使用同步接口
   - 大批量（1000-10000条）：建议使用异步接口
   - 超大批量（>10000条）：分多次调用或联系管理员

2. **并发控制**：
   - 根据服务器配置调整线程池大小
   - 监控数据库连接池使用情况
   - 避免在业务高峰期执行大批量操作

3. **监控告警**：
   - 设置失败率阈值告警
   - 监控处理耗时，及时发现性能问题
   - 定期清理过期任务状态

## 注意事项

1. **权限控制**：需要管理员角色权限（ROLE_EXECUTIVE_ASSISTANT_ADM）
2. **数据校验**：接口会自动校验人员信息的有效性
3. **事务处理**：每个批次都是独立事务，失败不影响其他批次
4. **性能监控**：大批量操作建议开启性能监控
5. **错误处理**：详细记录错误信息，便于问题排查

## 扩展功能

### 未来优化方向
1. 支持更灵活的分批策略
2. 添加重试机制
3. 支持暂停/恢复操作
4. 添加更详细的性能统计
5. 支持分布式部署下的协调处理

# 3.Thread、Runnable、Callable、Future、CompletableFuture详解
## 概述

Thread、Runnable、Callable、Future 和 CompletableFuture 是 Java 并发编程中的核心概念，它们分别代表不同的抽象层次和功能。本文详细介绍这些概念的区别和用法。

## 1. Thread（线程）

Thread 是 Java 中最基本的线程类，它代表一个线程的执行单元。

### 主要特点：
- 直接创建和启动线程
- 继承 Thread 类或实现 Runnable 接口
- 每个 Thread 对象代表一个实际的操作系统线程

### 使用示例：
```java
// 方式1：继承 Thread 类
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread 执行");
    }
}

// 方式2：实现 Runnable 接口
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Runnable 执行");
    }
}

// 使用
MyThread thread = new MyThread();
thread.start(); // 启动线程

Thread thread2 = new Thread(new MyRunnable());
thread2.start();
```

## 2. Runnable（可运行的任务）

Runnable 是一个函数式接口，只定义了一个 `run()` 方法，没有返回值。

### 主要特点：
- 函数式接口：`@FunctionalInterface`
- `run()` 方法无返回值
- 适合执行没有结果的任务
- 可以被线程池复用

### 使用示例：
```java
Runnable task = () -> {
    System.out.println("执行任务");
    // 没有返回值
};

// 提交给线程池
ExecutorService executor = Executors.newFixedThreadPool(5);
executor.submit(task);
```

## 3. Callable（可调用的任务）

Callable 类似于 Runnable，但 `call()` 方法可以有返回值，并且可以抛出异常。

### 主要特点：
- 函数式接口：`@FunctionalInterface`
- `call()` 方法有返回值：`V call() throws Exception`
- 支持泛型返回值
- 必须配合 ExecutorService 使用

### 使用示例：
```java
Callable<String> task = () -> {
    Thread.sleep(1000);
    return "任务完成结果";
};

ExecutorService executor = Executors.newCachedThreadPool();
Future<String> future = executor.submit(task);
```

## 4. Future（异步计算的结果）

Future 代表异步计算的结果，它提供了检查计算是否完成、等待完成和获取结果的方法。

### 主要特点：
- 代表异步计算的结果
- 提供阻塞和非阻塞的方法获取结果
- 可以取消任务执行
- 常用方法：
  - `get()` - 阻塞等待结果
  - `get(long, TimeUnit)` - 带超时的等待
  - `isDone()` - 检查是否完成
  - `cancel(boolean)` - 取消任务

### 使用示例：
```java
ExecutorService executor = Executors.newFixedThreadPool(5);
Future<String> future = executor.submit(() -> {
    Thread.sleep(2000);
    return "异步计算结果";
});

// 检查是否完成
if (future.isDone()) {
    String result = future.get(); // 立即获取
} else {
    // 等待最多3秒
    try {
        String result = future.get(3, TimeUnit.SECONDS);
        System.out.println(result);
    } catch (TimeoutException e) {
        future.cancel(true); // 取消任务
    }
}
```

## 5. CompletableFuture（可完成的 Future）

CompletableFuture 是 Java 8 引入的更强大的异步编程工具，它实现了 Future 接口并提供了丰富的异步操作方法。

### 主要特点：
- 继承 Future 和 CompletionStage
- 支持回调函数（thenApply、thenAccept、thenRun）
- 支持组合操作（thenCombine、thenCompose）
- 支持异常处理（exceptionally、handle）
- 支持多个异步操作的协调（allOf、anyOf）
- 可以手动完成（complete、completeExceptionally）

### 使用示例：
```java
// 基本使用
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    // 异步执行的任务
    return "异步结果";
});

// 回调处理结果
future.thenAccept(result -> {
    System.out.println("处理结果: " + result);
});

// 链式调用
CompletableFuture<String> chained = CompletableFuture.supplyAsync(() -> "Hello")
    .thenApply(s -> s + " World")  // 转换结果
    .thenApply(String::toUpperCase) // 再次转换
    .exceptionally(e -> "Error: " + e.getMessage()); // 异常处理

// 组合多个异步操作
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Task1");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "Task2");

CompletableFuture<String> combined = future1.thenCombine(future2, (r1, r2) -> r1 + " + " + r2);

// 等待所有完成
CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2);
allOf.thenRun(() -> System.out.println("所有任务完成"));
```

## 主要区别总结

| 特性 | Thread | Runnable | Callable | Future | CompletableFuture |
|------|--------|----------|----------|--------|------------------|
| **抽象层次** | 线程实现 | 任务接口 | 任务接口 | 结果表示 | 增强的异步工具 |
| **返回值** | 无 | 无 | 有 | 有 | 有 |
| **异常处理** | 需手动处理 | 需手动处理 | 可抛异常 | 需手动处理 | 内置异常处理 |
| **回调支持** | 无 | 无 | 无 | 无 | 支持 |
| **组合操作** | 无 | 无 | 无 | 无 | 支持 |
| **手动完成** | 不适用 | 不适用 | 不适用 | 不适用 | 支持 |
| **使用场景** | 直接线程控制 | 简单任务 | 有返回值的任务 | 异步结果获取 | 复杂的异步编程 |

## 使用建议

1. **Thread**: 当需要直接控制线程生命周期时使用
2. **Runnable**: 简单的无返回值任务，适合线程池
3. **Callable**: 需要返回结果的任务，必须配合 ExecutorService
4. **Future**: 基本的异步结果获取和任务取消
5. **CompletableFuture**: 现代异步编程，推荐在 Java 8+ 项目中使用

## 实际应用场景

### 场景1：简单的异步任务
```java
// 使用 Runnable
Runnable task = () -> sendEmail(user);
executor.submit(task);

// 使用 Callable
Callable<Boolean> task = () -> sendEmailAndGetResult(user);
Future<Boolean> future = executor.submit(task);
```

### 场景2：复杂的异步流程
```java
// 使用 CompletableFuture
CompletableFuture<User> userFuture = CompletableFuture.supplyAsync(() -> getUser(userId));
CompletableFuture<Order> orderFuture = CompletableFuture.supplyAsync(() -> getOrder(orderId));

CompletableFuture<String> result = userFuture.thenCombine(orderFuture, (user, order) -> {
    return processOrder(user, order);
}).thenApply(this::formatResult)
 .exceptionally(throwable -> {
     log.error("处理失败", throwable);
     return "处理失败";
 });
```

### 场景3：多个异步任务协调
```java
// 等待所有任务完成
CompletableFuture<Void> allTasks = CompletableFuture.allOf(
    task1, task2, task3, task4
);

allTasks.thenRun(() -> {
    System.out.println("所有任务已完成");
});

// 任意一个任务完成就继续
CompletableFuture<Object> anyTask = CompletableFuture.anyOf(
    task1, task2, task3
);
```

## 性能对比

### 线程创建方式对比：
1. **继承 Thread**: 每次创建新线程，开销大，不推荐
2. **实现 Runnable**: 更好的抽象，可以复用，推荐
3. **线程池 + Runnable/Callable**: 最高效，资源复用

### 异步编程方式对比：
1. **Future**: 基础异步支持，需要手动处理结果
2. **CompletableFuture**: 丰富的异步操作，链式调用，异常处理完善

## 注意事项

1. **线程安全**: 多线程环境下要注意共享数据的线程安全
2. **异常处理**: 异步任务中的异常不会自动传播，需要特别处理
3. **资源管理**: 线程池使用完毕后要正确关闭
4. **阻塞操作**: 避免在异步任务中使用阻塞操作
5. **上下文传递**: 在异步调用中注意线程上下文的传递

## 总结

- **Thread** 是线程的直接实现，适合简单的线程控制
- **Runnable** 是最基础的任务抽象，无返回值
- **Callable** 支持有返回值和异常抛出
- **Future** 提供了异步结果的获取和取消功能
- **CompletableFuture** 是最强大的异步编程工具，支持回调、组合、异常处理等高级功能

在现代 Java 开发中，推荐使用 **CompletableFuture** 进行异步编程，它提供了最丰富和实用的 API。

## 补充
#### 1. 支持回调函数（thenApply、thenAccept、thenRun）

这些方法用于在异步任务完成后执行后续操作：

- **thenApply(Function)**: 对结果进行转换，返回新的CompletableFuture
  ```java
  CompletableFuture.supplyAsync(() -> "hello")
      .thenApply(s -> s.toUpperCase())  // 返回CompletableFuture<String>
  ```

- **thenAccept(Consumer)**: 消费结果，无返回值
  ```java
  CompletableFuture.supplyAsync(() -> "hello")
      .thenAccept(s -> System.out.println(s))  // 返回CompletableFuture<Void>
  ```

- **thenRun(Runnable)**: 执行任务，不关心前面的结果
  ```java
  CompletableFuture.supplyAsync(() -> "hello")
      .thenRun(() -> System.out.println("完成"))  // 返回CompletableFuture<Void>
  ```

#### 2. 支持组合操作（thenCombine、thenCompose）

用于组合多个异步操作：

- **thenCombine**: 组合两个独立的CompletableFuture，结果合并
  ```java
  CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "hello");
  CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "world");

  CompletableFuture<String> combined = future1.thenCombine(future2, (s1, s2) -> s1 + " " + s2);
  ```

- **thenCompose**: 一个CompletableFuture依赖另一个的结果，扁平化嵌套
  ```java
  CompletableFuture<CompletableFuture<String>> nested = future1.thenApply(s -> getAnotherFuture(s));
  CompletableFuture<String> flat = future1.thenCompose(s -> getAnotherFuture(s));
  ```

#### 3. 支持异常处理（exceptionally、handle）

处理异步操作中的异常：

- **exceptionally(Function)**: 仅在发生异常时执行，提供默认值
  ```java
  future.exceptionally(ex -> "默认值")
  ```

- **handle(BiFunction)**: 无论成功还是失败都会执行，可以同时处理结果和异常
  ```java
  future.handle((result, ex) -> {
      if (ex != null) return "处理异常";
      return result;
  })
  ```

#### 4. 支持多个异步操作的协调（allOf、anyOf）

协调多个异步操作：

- **allOf**: 等待所有异步操作完成
  ```java
  CompletableFuture.allOf(future1, future2, future3)
      .thenRun(() -> System.out.println("所有任务完成"));
  ```

- **anyOf**: 等待任意一个异步操作完成
  ```java
  CompletableFuture.anyOf(future1, future2, future3)
      .thenAccept(result -> System.out.println("第一个完成的结果: " + result));
  ```

#### 5. 可以手动完成（complete、completeExceptionally）

手动控制CompletableFuture的完成：

- **complete(T)**: 手动设置正常完成的结果
  ```java
  CompletableFuture<String> future = new CompletableFuture<>();
  future.complete("手动完成");
  ```

- **completeExceptionally(Throwable)**: 手动设置异常完成
  ```java
  future.completeExceptionally(new RuntimeException("手动异常"));
  ```