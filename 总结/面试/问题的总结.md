## 当前系统日志是怎么实现的，并集成到研发云

### 一、日志实现整体结构

系统日志在 **gcommon 基础日志** 之上，由 **corehrpt-basic** 提供多套可选的日志能力，通过配置开关按需启用。

| 能力 | 配置开关 | 作用 | 主要类 |
|------|----------|------|--------|
| 基础日志 | gcommon 提供 | Logback 基础配置、CONSOLE/FILE 等 Appender | `gcommon-logging-base.xml` |
| 请求级 TraceId | `corehr.logging.trace.enable=true` | 为请求生成/透传 traceId，写入 MDC，便于链路追踪 | TraceIdFilter、TraceIdFeignRequestInterceptor |
| 地域标签 RegionTag | `corehr.logging.region.enable=true`（默认 true） | 从请求头取 regionTag，跨服务透传 | RegionTagFilter、RegionTagFeignRequestInterceptor |
| 日志增强（入参/出参/SQL） | `corehr.logging.advance.enable=true` | 记录 URL/Client IP、方法入参/返回值、SQL（可排除路径） | ClientInfoFilter、LoggingAdvanceAspect、SqlInterceptor |
| 安全审计日志 | `corehr.logging.security.enable=true` | 对指定路径记录用户、IP、SQL、操作结果等，输出到 security.log | SecurityLogFilter、SecurityLoggingAdvanceAspect |
| 操作日志落库 | 注解驱动 | 带 `@CoreHrLogOperation` 的接口：入参、结果、异常写入 **t_opt_log** | CoreHrOperationLogAspect、OptLogMapper |

- **Controller 标记**：对外接口常用 **`@GCommonLog`**（来自 gcommon），用于请求/响应等统一日志，与上述能力配合使用。

### 二、各层实现要点

1. **TraceId**  
   - **TraceIdFilter**：从请求头取 traceId，没有则生成，放入 **MDC** 和 **TraceIdContextHolder**，响应头带回。  
   - **TraceIdFeignRequestInterceptor**：Feign 调用时把 traceId 放进请求头，实现跨服务传递。  
   - 这样 Logback 的 pattern 里可用 `%X{traceId}` 等，便于研发云/日志平台按 traceId 串起一条请求链。

2. **RegionTag**  
   - **RegionTagFilter**：从请求头取 regionTag，设到 **RegionTagContextHolder**，响应头带回。  
   - **RegionTagFeignRequestInterceptor**：Feign 时透传 regionTag。  
   - 用于多地域/多环境时在日志中区分流量来源。

3. **日志增强（advance）**  
   - **ClientInfoFilter**：根据 `corehr.logging.advance.config` 的 exclude 等配置，对未排除的请求打 URL、Headers、Client IP、Server IP。  
   - **LoggingAdvanceAspect**：对满足条件的请求，AOP 打印方法入参、返回值（可脱敏、截断）。  
   - **SqlInterceptor**：可选打印 SQL 及影响行数。  
   - `/openapi/**` 在 **UserInfoInterceptor** 里被排除，不参与上述增强。

4. **安全日志（security）**  
   - **SecurityLogFilter**：仅对配置的 **securityPaths** 生效，请求开始时构造 **SecurityLogBean**（时间、User-Agent、源 IP、URL、方法等），请求结束时把本线程收集的 SQL 一并写入 Bean，最后用 `log.info("[Security Log]:{}", logBean)` 打出。  
   - 安全日志使用独立 **logback 配置**：`corehrpt-basic/.../logging/security/logback.xml`，其中引用了 **gcommon 的 base**（`com/oppo/gcommon/starter/logging/logback/gcommon-logging-base.xml`），并为 `SecurityLogFilter` 的 Logger 配置了 **FILE_SECURITY**（如 `logs/security.log`），按大小+时间滚动。

5. **操作日志落库**  
   - 在方法上打 **`@CoreHrLogOperation`**，**CoreHrOperationLogAspect** 在 Before 阶段把 IP、URI、Method、参数、用户、开始时间等放入 **OptContextHolder**，在 AfterReturning/AfterThrowing 时把结果或异常写入 **OptLogDTO**，通过 **OptLogMapper** 插入 **t_opt_log**。

### 三、与研发云的集成方式

1. **基于 gcommon 的日志底座**  
   - 应用通过 **gcommon-starter-logging** 的 `gcommon-logging-base.xml` 使用统一的 Logback 配置（格式、CONSOLE/FILE 等）。  
   - 研发云侧通常通过 **标准输出** 或 **约定目录下的日志文件** 采集日志；本系统按 gcommon 规范输出，即可被研发云日志采集 agent 统一采集、解析。

2. **TraceId + MDC**  
   - TraceId 放入 **MDC**，并在 HTTP 响应头、Feign 请求头中透传，整条调用链使用同一 traceId。  
   - 研发云日志平台只要在日志解析规则中提取 **traceId**（或对应字段），即可做链路查询、关联前后端与多服务。

3. **RegionTag 透传**  
   - 请求头带入的 regionTag 经 Filter 与 Feign 透传，便于在日志中按地域/环境过滤，与研发云多环境、多地域的视图一致。

4. **安全日志独立文件**  
   - 安全审计日志写入 `logs/security.log`，可与普通业务日志分开采集、单独授权与审计，符合研发云安全与合规需求。

5. **API 集市（开放接口）**  
   - 配置中有 **API 集市**（apimarket.myoas.com）相关配置，用于对外暴露/订阅 API；与“日志”的集成主要体现在：对外调用可结合 TraceId/RegionTag 在日志中追踪，并与研发云的 API 网关、监控体系配合。

**总结**：日志实现 = **gcommon 基础 Logback + corehrpt-basic 的 TraceId/RegionTag/增强/安全/操作落库**；与研发云的集成 = **统一格式与输出（gcommon base）+ TraceId/MDC 链路追踪 + 文件/标准输出供平台采集**。若你们内部“研发云”特指某平台（如统一日志中心、APM），只需确认其采集的是 stdout 还是指定路径下的日志文件，并保证 logback 的 appender 与格式与之匹配即可。

---

## 各个模块之间是怎么调用的，怎么判断是系统内部的请求还是外部的请求

### 一、模块间调用方式

各模块之间通过 **Spring Cloud OpenFeign** 做 RPC 调用：

1. **定义 Feign 接口**：各模块在 `*RpcApi` 接口上使用 `@FeignClient(name = "服务名", path = "上下文路径")`，例如：
   - `PersRpcApi`：`@FeignClient(name = "corehrweb-pers", path = "/corehrpt-pers")`
   - `CommonRpcApi`：`@FeignClient(name = "corehrweb-common", path = "/corehrpt-common")`
   - `WorkflowRpcApi`：`@FeignClient(name = "corehrweb-workflow", path = "/corehrpt-workflow")`
2. **接口方法路径**：RPC 接口方法统一使用 **`/openapi/v1` 或 `/openapi/v2`** 前缀，例如 `@PostMapping("/openapi/v2/emp-personal/list-one")`。
3. **启动类**：各服务在启动类上使用 `@EnableFeignClients("com.oppo.corehrpt")` 扫描并注册 Feign 客户端。
4. **调用链**：A 模块注入 B 模块的 `*RpcApi`，调用其方法时，Feign 会向 B 服务的 `path + 方法路径`（如 `/corehrpt-pers/openapi/v2/attendance/calendar`）发起 HTTP 请求。

### 二、内部请求 vs 外部请求的区分

| 维度       | 外部请求（用户/前端）           | 内部请求（系统内 Feign 调用）      |
|------------|--------------------------------|-----------------------------------|
| **路径**   | `/api/v2/...`                  | `/openapi/v1` 或 `/openapi/v2/...` |
| **入口**   | 对外 Controller（如 `EmpIndexController`） | RPC Controller（如 `EmpIndexAttendanceRpcController`） |
| **鉴权**   | `@UserAuthorization`，从网关/登录态取用户 | 无登录鉴权，通过参数传 `oprid` 等   |
| **谁发起** | 浏览器/前端经网关               | 其他微服务通过 Feign               |
| **签名**   | 无（或网关/4A 鉴权）            | Feign 请求带 `x-core-nonce`、`x-core-timestamp`、`x-core-sign` |

判断方式可以归纳为：

1. **按 URL 前缀**
   - **`/api/`**：对外暴露的接口，面向用户/前端，需登录鉴权。
   - **`/openapi/`**：内部 RPC 或开放接口，由 Feign 或带签名的外部系统调用。

2. **按请求头（openapi 签名）**
   - 内部 Feign 调用时，若配置了 `api-auth.openapi-sign.client=true`，**FeignRequestInterceptor** 会为每次请求加上：
     - `x-core-nonce`
     - `x-core-timestamp`
     - `x-core-sign`（用 secret 对 method + path + nonce + timestamp 签名）
   - 被调方若开启 `api-auth.openapi-sign.server=true`，**OpenApiSignFilter** 会对 **`/openapi/**`** 做签名校验（白名单内的接口除外），从而识别并放行“内部/合法开放”请求，拒绝未带正确签名的请求。

3. **同一业务的两种入口**
   - 同一能力往往有两套入口：一套给前端（`/api/` + `@UserAuthorization` + `UserContextHolder.getUserAccount()`），一套给内部 RPC（`/openapi/` + 参数里传 `oprid`）。
   - 例如考勤日历：`EmpIndexController` 的 `/api/v2/attendance/calendar`（当前登录人）与 `EmpIndexAttendanceRpcController` 的 `/openapi/v2/attendance/calendar`（传入 oprid）。

### 三、相关代码位置（简要）

- Feign 调用时传递 token 和 openapi 签名：`corehrpt-basic/.../config/FeignRequestInterceptor.java`
- openapi 签名校验（服务端）：`corehrpt-basic/.../filter/OpenApiSignFilter.java`
- 只对 `/openapi/**` 注册签名过滤器：`corehrpt-basic/.../config/OpenApiSignWebConfig.java`
- openapi 请求解析 token 以便拿用户信息：`corehrpt-basic/.../token/CusTokenAutoConfiguration.java`（对 `/openapi/**` 注册 CusTokenParseInterceptor）

---

## 当前系统是怎么接入 4A 平台的

4A 平台在本项目中作为 **统一认证（OAuth2/SSO）** 使用，域名示例：`https://test-4a.wanyol.com/siam`。接入方式可概括为：**gcommon SSO 配置 + 自定义回调与拦截器 + 特权账号二次认证（AIDC）**。

### 一、配置层面

在 `application-*.yml` 中通过 **gcommon.sso** 对接 4A（OAuth2/SIAM）：

```yaml
gcommon:
  sso:
    oauth2:
      baseUrl: https://test-4a.wanyol.com/siam      # 4A 认证中心地址
      baseApiUrl: https://test-4a.wanyol.com/siam
      appId: CoreHR                                  # 在 4A 侧注册的应用 ID
      appSecret: xxx
      redirect-url: https://hr-xxx.oasqa.com/corehrpt-api/api/v1/sso/callback  # 授权后回调地址
      redirect-url-with-token: true
```

在 **service-shared.yml**（或各服务共享配置）中通过 **corehr.oauth2** 配置本系统侧回调路径与前端白名单：

```yaml
corehr:
  oauth2:
    redirectPath: /corehrpt-api/api/v1/sso/callback
    redirectUrlList:   # 允许的回调域名列表（若使用）
      - https://hr-sit.oasqa.com
      - https://hr-sit.wanyol.com
    frontWhiteList:    # 前端访问域名白名单，未登录时跳转 4A 登录页会用到的 redirect_url
      - http://localhost
      - https://hr-sit.oasqa.com
```

即：**4A 负责发码、换 token、查用户信息**；**本系统负责提供 redirect-url、接收 code、换 token、写 Cookie、放行/拦截请求**。

### 二、登录流程（用户从浏览器访问）

1. **未登录用户访问需鉴权接口**  
   - **OAuth2AuthenticationInterceptor**（corehrpt-basic 自定义，继承 gcommon 的 OAuth2 拦截器）发现请求里没有有效 token（Cookie `GCOMMON_USER_TOKEN` 或 Header `authorization`）。  
   - 根据当前请求的 Referer/BaseUrl 与 **frontWhiteList** 决定 redirect_url，再拼出 4A 登录页地址：`baseUrl + authorizeUrl`，并带上 `client_id`、`redirect_url`、`state`（回调后要跳回的前端地址）。  
   - 通过 302 把用户重定向到 **4A 登录页**。

2. **用户在 4A 侧登录成功后**  
   - 4A 带着 **code** 和 **state** 重定向到本系统配置的 **redirect-url**（即 `CustomLoginController` 的 callback 地址，如 `/api/v1/sso/custom/callback`）。

3. **CustomLoginController.callback**  
   - 用 **code** 调 4A 的 token 接口（**SsoUtil.getAccessToken**）拿到 **access_token**。  
   - 用 access_token 调 4A 用户信息接口（**SsoUtil.getUserInfo**）拿到用户信息，封装成 **LoginUserBean** 放入 **UserContextHolder**。  
   - 将 access_token 写入 Cookie（**GCOMMON_USER_TOKEN**），过期时间以 4A 返回为准。  
   - 若开启 **特权账号二次认证**：判断当前用户是否在 Redis 特权名单（**PrivilegeUserUtil.isPrivilegeUser**），若是且未做过二次认证，则重定向到 4A 的 **AIDC 二次认证页**（**PrivilegeUserUtil.getLoginUrl**），否则继续。  
   - 最后根据 **state** 或默认地址 **redirect** 回前端（可选在 URL 上带 `token=xxx`，由 `redirect-url-with-token` 控制）。

4. **二次认证回调（如启用）**  
   - 4A AIDC 回调到 **secondCallback**（如 `/api/v1/sso/aidc/callback`）。  
   - 用 code 换 **id_token**，并与当前用户的 access_token 一起写入 Redis（**PrivilegeUserUtil.setIdTokenCache**），表示该特权用户已完成二次认证。  
   - 再重定向回前端。

5. **后续请求**  
   - 请求带上 Cookie（或 Header）中的 token，**OAuth2AuthenticationInterceptor** 通过 **UserTokenProvider.getUserInfoByToken** 校验 token（或从缓存取用户信息），并做 **PrivilegeUserUtil.checkSecondAuth**（特权账号必须已有二次认证记录），通过则把用户写入 **UserContextHolder**，业务层用 **@UserAuthorization** 的接口即可拿到当前用户。

### 三、关键组件与职责

| 组件 | 作用 |
|------|------|
| **gcommon.sso.oauth2** | 4A 的 baseUrl、appId、appSecret、redirect-url 等，由 gcommon 的 SsoUtil、OAuth2 能力使用 |
| **CoreHROAuth2Config** | 本系统扩展：redirectPath、frontWhiteList，用于支持多前端域名的登录跳转 |
| **OAuth2AuthenticationInterceptor** | 请求前校验 token，无 token 或无效时重定向到 4A 登录页；支持 frontWhiteList 决定 redirect_url；校验通过后设置 UserContextHolder，并做特权账号二次认证校验 |
| **CustomLoginController** | 承接 4A 的 code 回调：换 token、取用户信息、写 Cookie、特权用户时跳转 AIDC、最终 redirect 回前端 |
| **PrivilegeUserUtil** | 特权账号名单（Redis）、二次认证 URL（4A AIDC）、id_token 缓存与校验 |
| **CorehrptUserAuthorizationConfiguration** | 提供 **UserAuthorizationProvider**：在已有认证（Cookie/Header token）的前提下，按 **corehrpt** 规则解析用户（含移动端 m-token 等），与 4A 登录后的 Cookie/Header 配合使用 |

### 四、与 4A 的接口约定（本系统作为 OAuth2 客户端）

- **授权登录页**：`baseUrl + authorizeUrl`，参数：client_id、redirect_uri、state 等。  
- **用 code 换 token**：SsoUtil.getAccessToken 内部调 4A 的 token 接口（如 `/v1/oauth2/access_token` 或 4A 文档约定）。  
- **用 access_token 拉用户信息**：SsoUtil.getUserInfo 调 4A 的用户信息接口。  
- **二次认证（AIDC）**：授权地址含 `/aidc/authorize`；用 code 换 id_token 的地址为 `/oppo-4a/4a-api/siam/aidc/accessToken`（见 **PrivilegeUserUtil**）。

### 五、配置与代码位置小结

- **4A 地址与应用信息**：`conf/application-sit0.yml`（或对应环境）中的 `gcommon.sso.oauth2`。  
- **回调路径与白名单**：`conf/service-shared.yml` 中的 `corehr.oauth2`。  
- **自定义 OAuth2 拦截器**：`corehrpt-basic/.../oauth2/OAuth2AuthenticationInterceptor.java`。  
- **登录与二次认证回调**：`corehrpt-basic/.../oauth2/CustomLoginController.java`。  
- **OAuth2 自动配置（注册拦截器）**：`corehrpt-basic/.../oauth2/CoreHROAuth2AutoConfiguration.java`（需 `corehr.oauth2.enable=true`）。  
- **特权账号与 AIDC**：`corehrpt-basic/.../util/PrivilegeUserUtil.java`。

**总结**：接入 4A = 在 gcommon 中配置 4A 的 OAuth2/SIAM 地址与应用凭证，把授权回调指向本系统的 CustomLoginController；本系统用自定义的 OAuth2AuthenticationInterceptor 做 token 校验与未登录时跳转 4A 登录页，用 CoreHROAuth2Config 支持多前端域名；特权账号通过 4A 的 AIDC 做二次认证，并在拦截器中强制校验。