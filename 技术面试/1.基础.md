## 1.Java中的基本数据类型
byte：1     short：2    int：4

long：8     float：4     double：8

boolean：1    char：2      

## 2.成员变量与局部变量的区别？
1.成员变量可以被public,static等修饰符修饰，而局部变量不能。

2.成员变量存在于堆内存，局部变量则存在于栈内存。

3.成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。

4.成员变量如果没有被赋初始值，会赋予默认值，而局部变量则不会自动赋值。

## 3.静态方法和实例方法
1.静态方法是属于类的，可以通过类名直接调用，而不需要创建类的实例。实例方法是属于对象的，需要通过对象来调用。

2.静态方法只允许访问静态成员，不允许访问实例成员，而实例方法可以。

## 4.重载和重写
1.重写是指子类中的方法与父类中继承的方法有完全相同的返回值类型、方法名、参数个数以及参数类型，这样就可以实现对父类方法的覆盖。

2.重载发生在同一个类中，方法名相同，参数列表不同。方法返回类型、权限修饰符不作为方法重载的依据。

## 5.抽象类和普通类有什么区别？
1.普通类可以直接实例化，而抽象类不能直接实例化。

2.抽象类中可以包含抽象方法和非抽象方法，而普通类只能包含非抽象方法。

3.普通类实现接口需要重写接口中的方法，而抽象类可以实现接口方法也可以不实现。

## 6.接口和抽象类有什么共同点和区别
1.相同点：

都不能被实例化。

都可以包含抽象方法。

2.不同点：

一个类只能继承一个类，但是可以实现多个接口。

抽象类有变量,常量，构造方法，抽象方法和非抽象方法。接口只有常量和抽象方法 。

接口主要用于对类的行为进行约束，抽象类主要用于代码复用，强调的是所属关系。

## 7.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？
1.浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。

2.深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

3.引用拷贝：两个不同的引用指向同一个对象<!-- 这是一张图片，ocr 内容为：引用拷贝 深拷贝 浅拷贝 堆 堆 堆 PERSON PERSON PERSON1 PERSON1 PERSON1 PERSON ADDRESS ADDRESS ADDRESS PERSON1COPY PERSON1COPY PERSON PERSONICOPY PERSON ADDRESS -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689143555816-bb7a2418-ef7c-4d6d-9c5e-7b9a4deee286.png)

## 8.String、StringBuffer、StringBuilder 的区别
1.String：线程安全，不可变的字符串，因此在动态字符串拼接的场景下不适合使用，效率很低（每次都会生成新的字符串）。

2.StringBuffer：线程安全，使用 synchronized 来保证线程安全。

3.StringBuilder：线程不安全，和 StringBuffer 有相同的API，但它可以更高效的拼接字符串。

## 9.String为什么是不可变的
 1.保存字符串的数组被 final 修饰且是私有的，并且String 类没有提供修改这个字符串的方法。 				2.String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。

## 10.面向对象三大特征？
1.封装：将数据和操作数据的方法包装在一起，对外隐藏内部实现细节，只提供有限的公共接口

2.继承：子类可以重用父类的属性和方法，同时还可以添加自己的属性和方法。

3.多态：同一个接口可以有不同的实现方式，即同一种行为可以有多种不同的表现形式。

## 11.继承的好处和弊端
    - 提高了代码的复用性和可维护性。
    - 增加了代码的耦合性。

## 12.final
    - final修饰类：该类不能被继承
    - final修饰方法：该方法不能被重写
    - final修饰基本数据类型：数据值不能发生改变
    -  final修饰引用数据类型：引用类型的地址不能发生改变

## 13.Exception 和 Error 有什么区别
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2022/png/34358440/1668386268749-d8367e7a-b631-4b2a-8814-c3c3f158b471.png)

1.编译时异常： 这些异常在编译阶段被检测到，程序在编译时必须处理这些异常，否则无法通过编译。

（IOException、SQLException）

2.运行时异常： 这些异常在运行时才被检测到，程序可以选择是否处理这些异常

（空指针、数组越界、算数异常）

3.错误：它表示严重的系统级问题，一般由虚拟机抛出，通常无法通过代码来处理

（OutOfMemoryError：内存不足错误。StackOverflowError：栈溢出错误。）

## 14.throws和throw的区别
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2022/png/34358440/1668386280267-89cfaa47-aa7e-4519-bf99-26e062bfc1fe.png)

## 15.反射
概述：

在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。

优缺点：

优点：可以让代码更加灵活、为各种框架提供便利

（Spring 的 IoC 容器通过反射来实现 Bean 的实例化和属性注入。AOP、SpringBoot的自动装配）

缺点：增加了安全问题。比如可以无视泛型参数的安全检查。另外，反射的性能也要稍差点。

## 16.获取 Class 对象的四种方式
+ 类名.class属性
+ 对象名.getClass()方法
+ Class.forName(全类名)方法
+ 通过类加载器xxxClassLoader.loadClass()传入类路径获取

```java
ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");
```

## 17.序列化
1. 序列化的主要目的是：将对象在内存中的状态转换为可以存储或传输的格式，方便进行数据的持久化存储或网络传输。

1.序列化：将对象转换成二进制字节流的过程

2.反序列化：将在序列化过程中所生成的二进制字节流转换成对象的过程

2. 对于不想进行序列化的变量，使用 transient 关键字修饰。
3. serialVersionUID 属于版本控制的作用。反序列化时，会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。

serialversionuid的作用是验证版本一致性。如果serialversionuid一致，说明他们的版本是一样的。

## 18.设计模式
[Java 代理模式详解](https://javaguide.cn/java/basis/proxy.html)



