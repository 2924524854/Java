## 1.OSI 七层模型
OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。

<!-- 这是一张图片，ocr 内容为：公众号:JAVAGUIDE 网站:JAVAGUIDE.CN 应用层 为计算机用户提供服务 数据处理(编解码,加密解密,压缩解压缩) 表示层 会话层 管理(建立,维护,重连)应用程序之间的会话 传输层 为两台主机进程之间的通信提供通用的数据传输服务 网络层 路由和寻址(决定数据在网络的游走路径) 数据链路层 帧编码和误差纠正控制 物理层 透明地传送比特流传输 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689648393697-4a2ed8f2-e40b-483f-8acd-74c5fc807c4e.png)

## 2.TCP/IP 四层模型
1.应用层

2.传输层

3.网络层

4.网络接口层

## 3.为什么网络要分层
1.各层之间相互独立，不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了

2.提高了整体灵活性，每一层都可以使用最适合的技术来实现。

3.将复杂的网络问题分解为许多小问题来处理，使得复杂的网络系统变得易于实现。

## 4.常见网络协议
应用层：

HTTP（超文本传输协议）：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议。

SSH（安全的网络传输协议）：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务

DNS（域名管理系统）: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。

传输层：

TCP（传输控制协议 ）：提供 面向连接 的，可靠 的数据传输服务。

UDP（用户数据协议）：提供 无连接 的，尽最大努力 的数据传输服务（不保证数据传输的可靠性），简单高效。

网络层：

IP（网际协议）：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。

ARP（地址解析协议）：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处。

## 5.从输入 URL 到页面展示到底发生了什么？
1.浏览器进行 DNS 解析，查找域名的IP地址

（寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器）

2.建立TCP/IP连接（三次握手具体过程）

3.浏览器向web服务器发送一个HTTP请求

4.经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器

5.服务器处理该HTTP请求，返回一个HTML文件

6.浏览器解析该HTML文件，并且显示在浏览器端

注意：

HTTP协议是一种基于TCP/IP的应用层协议，进行HTTP数据请求必须先建立TCP/IP连接

## 6.HTTP 状态码
1XX：消息状态码。

2XX：成功状态码。

3XX：重定向状态码。

4XX：客户端错误状态码。

5XX：服务端错误状态码。

常见状态码：

200：请求成功；

301：永久重定向；

302：临时重定向；

404：无法找到此页面；

405：请求的方法类型不支持；

500：服务器内部出错。

## 7.HTTPS
HTTPS（安全的超文本传输协议）是一种基于 SSL/TLS 协议的 HTTP 协议，它是 HTTP 协议的安全版本。HTTPS 协议通过加密通信内容和身份验证来保证数据传输的安全性和完整性，防止数据在传输过程中被窃取或篡改。

## 8.HTTP 和 HTTPS 有什么区别？（重要）
1.端口号：HTTP 默认是 80，HTTPS 默认是 443。

2.URL 前缀：HTTP 的 URL 前缀是 http，HTTPS 的 URL 前缀是 https。

3.安全性和资源消耗：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议 。所有传输的内容都经过加密，加密采用对称加密，对称加密的密钥用服务器的证书进行了非对称加密。

## 9.HTTP各版本比较
1.1：

1.HTTP/1.0 为短连接，HTTP/1.1 支持长连接。

2.HTTP/1.1 中新加入了大量的状态码。

2.0：

1.HTTP/2.0 采用IO多路复用，在处理多个请求时更加高效，减少了网络延迟和提高了性能。

2.HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。

3.0：

1.HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了 QUIC协议来实现可靠的传输，提供与SSL/TLS相当的安全性，具有较低的连接和传输延迟。

## 10.TCP和UDP的区别
1.TCP 是面向连接的协议，需要在客户端和服务器之间建立一个稳定的连接，然后再进行数据传输；而 UDP 是无连接的协议，数据包可以直接发送给目标主机，不需要事先建立连接。

2.TCP 采用可靠的数据传输方式，而 UDP 采用不可靠的数据传输方式。

3.UDP的传输效率比TCP高。

4.TCP 对数据包的大小有限制，最大只能传输 64KB 的数据，而 UDP 的数据包大小没有限制。

## 11.TCP 三次握手
● SYN 连接请求报文

● seq  序号

● ACK 确认连接

● ack 确认号

<!-- 这是一张图片，ocr 内容为：客户 服务器 B CLOSED CLOSED 被动打开 主动打开 SYN1,SEGX LISTEN SYN- SENT SYN-L,ACK-L,SEQ-Y,ACK-1 SYN ACK1,SEQX+1,ACK-Y+1 RCVD ESTAB LISHED 数据传送 ESTAB- LISHED -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689663965587-0b583599-3f89-4507-8a65-d0699d8c40e8.png)

<!-- 这是一张图片，ocr 内容为：SERVE CLIENT CLIENT SERVER 公众号:JAVAGUIDE 公众号:JAVAGUIDE 网站:JAVAGUIDE.CN 网站:JAVAGUIDE.CN FIN(SEQX) SYN(SEQ-X) ACK (ACK+1) SYN+ACK(SEQYACKX+1) FIN(SEQY) ACK(ACKY+1) ACK(ACK+1) -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690706228664-53b4da92-5628-4cb8-8ce9-845298c17cf0.png)

1.客户端向服务器发送一个 SYN 包，SYN 标识位为 1，表示客户端请求建立连接，并指定随机序列号为 x。

2.服务器收到客户端的 SYN 包后，向客户端发送一个 SYN+ACK 包，其中 SYN 和 ACK 标识位均为 1，表示服务器接收到了客户端的请求，并同意建立连接。同时服务器也会指定一个随机的序列号 y，并将确认号设置为 x+1。

3.客户端收到服务器的 SYN+ACK 包后，向服务器发送一个 ACK 包，其中 ACK 标识位为 1，表示客户端确认收到了服务器的响应，并将确认号设置为 y+1。

## 12.为什么要三次握手?
因为 TCP是全双工通信，所以要经过 3 次交互才能确认双方的发送能力和接收能力。

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收。

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常。

## 13.TCP四次挥手
<!-- 这是一张图片，ocr 内容为：服务器 客户 B ESTAB 通知 数据传送 LISHED 主动关闭 应用 ESTAB- FIN1,SEQPU 进程 LISHED FIN WAIT-1 CLOSE- ACK1,SEQ-V,ACK-U+1 WAIT 被动关闭 数据传送 FIN FIN1.ACK1,SEQ-WACK-U+1 WAIT-2 LAST- ACK1,SEQU+1,ACK-W+1 等待2MSL ACK TIME- WAIT CLOSED CLOSED -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689663983062-496610e2-0f99-40e4-9cbf-5c0753471dc2.png)

<!-- 这是一张图片，ocr 内容为：SERVE CLIENT CLIENT SERVER 公众号:JAVAGUIDE 公众号:JAVAGUIDE 网站:JAVAGUIDE.CN 网站:JAVAGUIDE.CN FIN(SEQX) SYN(SEQ-X) ACK (ACK+1) SYN+ACK(SEQYACKX+1) FIN(SEQY) ACK(ACKY+1) ACK(ACK+1) -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690706228664-53b4da92-5628-4cb8-8ce9-845298c17cf0.png)

1.客户端发送一个 FIN 包，其中 FIN 标识位为 1，表示客户端希望关闭连接。并指定随机序列号为 x。

2.服务器收到客户端的 FIN 包后，向客户端发送一个 ACK 包，其中 ACK 标识位为 1，表示服务器已经收到了客户端的请求，并将确认号设置为x+1。

3.服务器在发送完 ACK 包之后，也会发送一个 FIN 包，其中 FIN 标识位为 1，表示服务器也希望关闭连接。同时服务器也会指定一个随机的序列号 y

4.客户端收到服务器的 FIN 包后，向服务器发送一个 ACK 包，其中 ACK 标识位为 1，表示客户端已经收到了服务器的请求，并将确认号设置为y+1。

## 14.为什么最后需要等待2MSL
1.确保最后一个确认报文能够到达（如果服务器没收到客户端发送的确认报文，就会重新发送连接释放请求报文）

2.避免新旧链接混淆。（等待2MSL可以让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接请求不会出现旧的连接请求报文）

## 15.为什么要四次挥手？
确保双方都能正确地关闭连接，并避免数据的丢失和混淆。

## 16.把服务器发送的 ACK 和 FIN 合并，变成三次挥手？
因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。

## 17.转发和重定向
1.转发地址栏不发生变化，重定向地址栏发生变化

       2.转发只能访问当前服务器下的资源，重定向可以访问其他服务器的资源。

3.转发可以使用request对象来共享数据，重定向不能使用request对象来共享数据，

## 
