## 1.软件设计原则
1.开闭原则：对扩展开放，对修改关闭

2.单⼀职责原则：⼀个类只负责⼀个功能领域中的相应职责

3.⾥⽒替换原则：所有引⽤基类的地⽅必须能透明地使⽤其⼦类的对象

4.依赖倒置原则：依赖于抽象，不能依赖于具体实现

5.接⼝隔离原则：类之间的依赖关系应该建⽴在最⼩的接⼝上

6.合成/聚合复⽤原则：尽量使⽤合成/聚合，⽽不是通过继承达到复⽤的⽬的

7.迪⽶特法则：⼀个软件实体应当尽可能少的与其他实体发⽣相互作⽤

## 1.好处：
提高代码质量、提高可维护性、增加可扩展性、降低耦合度

## 2.工厂模式[Java设计模式之创建型：工厂模式详解（简单工厂+工厂方法+抽象工厂）_简单工厂模式,工厂方法模式,抽象工厂模式_张维鹏的博客-CSDN博客](https://blog.csdn.net/a745233700/article/details/120253639)
概念：

在创建对象时，不会对客户端暴露对象的创建逻辑，而是通过使用共同的接口来创建对象。

1.简单工厂：

增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。

2.工厂方法：

每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。

3.抽象工厂：

当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。

## 3.工厂模式实现
不使用工厂：

```java
public class Apple {
    public void display() {
        System.out.println("apple");
    }
}
 
public class Orange {
    public void display() {
        System.out.println("orange");
    }
}
 
public class Test {
    public static void main(String[] args) {
        Apple apple = new Apple();
        Orange orange = new Orange();
        apple.display();
        orange.display();
    }
}
```

简单工厂：

```java
// 产品类
public interface Fruit {
    void display();
}
 
public class Apple implements Fruit{
    @Override
    public void display() {
        System.out.println("apple");
    }
}
public class Orange implements Fruit{
    @Override
    public void display() {
        System.out.println("orange");
    }
}
// 工厂类———————————————————————————————————————————————————————————————————————————————————
public class Factory {
    public Fruit createFruit(String name) {
        if ("apple".equals(name)) {
            return new Apple();
        }else if ("orange".equals(name)) {
            return new Orange();
        }
        return null;
    }
}
// 用户类：——————————————————————————————————————————————————————————————————————————————
public class Test {
    public static void main(String[] args) throws Exception {
        Factory factory = new Factory();
        Fruit apple = factory.createFruit("apple");
        Fruit orange = factory.createFruit("orange");
        apple.display();
        orange.display();
    }

}
```

工厂方法模式：

```java
// 产品类_________________________________________________________________________________
public interface Fruit {
    void display();
}
 
public class Apple implements Fruit{
    @Override
    public void display() {
        System.out.println("apple");
    }
}
public class Orange implements Fruit{
    @Override
    public void display() {
        System.out.println("orange");
    }
}
// 工厂类———————————————————————————————————————————————————————————————————————————————————
public interface FactoryFruit {
    Fruit createFruit();
}
 
public class FactoryApple implements FactoryFruit{
    @Override
    public Fruit createFruit() {
        return new Apple();
    }
}
public class FactoryOrange implements FactoryFruit{
    @Override
    public Fruit createFruit() {
        return new Orange();
    }
}
// 用户类：—————————————————————————————————————————————————————————————————————————————————
public class Test {
    public static void main(String[] args) {
        FactoryApple factoryApple = new FactoryApple();
        Fruit apple = factoryApple.createFruit();
        FactoryOrange factoryOrange = new FactoryOrange();
        Fruit orange = factoryOrange.createFruit();
        apple.display();
        orange.display();
    }
}
```

抽象工厂模式：

```java
// 产品类_______________________________________________________________________________
//发动机以及型号  
public interface Engine {}  
 
public class EngineA implements Engine{  
    public EngineA(){  
        System.out.println("制造-->EngineA");  
    }  
}  
public class EngineB implements Engine{  
    public EngineB(){  
        System.out.println("制造-->EngineB");  
    }  
}  
 
 
//空调以及型号  
public interface Aircondition {} 
 
public class AirconditionA implements Aircondition{  
    public AirconditionA(){  
        System.out.println("制造-->AirconditionA");  
    }  
}  
public class AirconditionB implements Aircondition{  
    public AirconditionB(){  
        System.out.println("制造-->AirconditionB");  
    }  
} 
// 工厂类———————————————————————————————————————————————————————————————————————————————————
//创建工厂的接口  
public interface AbstractFactory {  
    //制造发动机
    public Engine createEngine();
    //制造空调 
    public Aircondition createAircondition(); 
}  
 
//为宝马320系列生产配件  
public class FactoryBMW320 implements AbstractFactory{     
    @Override  
    public Engine createEngine() {    
        return new EngineA();  
    }  
    @Override  
    public Aircondition createAircondition() {  
        return new AirconditionA();  
    }  
}  
//宝马523系列
public class FactoryBMW523 implements AbstractFactory {  
     @Override  
    public Engine createEngine() {    
        return new EngineB();  
    }  
    @Override  
    public Aircondition createAircondition() {  
        return new AirconditionB();  
    }  
} 
// 用户类：—————————————————————————————————————————————————————————————————————————————————
public class Customer {  
    public static void main(String[] args){  
        //生产宝马320系列配件
        FactoryBMW320 factoryBMW320 = new FactoryBMW320();  
        factoryBMW320.createEngine();
        factoryBMW320.createAircondition();
          
        //生产宝马523系列配件  
        FactoryBMW523 factoryBMW523 = new FactoryBMW523();  
        factoryBMW523.createEngine();
        factoryBMW523.createAircondition();
    }  
}
```

## 4.单例模式[Java设计模式之创建型：单例模式_懒汉式单例、饿汉式单例、登记式单例_张维鹏的博客-CSDN博客](https://blog.csdn.net/a745233700/article/details/83618800)
概念：

确保系统中某个类只有一个实例，该类自行实例化并向整个系统提供这个实例的公共访问点。

优点：

1.系统中只存在一个共用的实例对象，无需频繁创建和销毁对象，节约了系统资源，提高系统的性能

2.可以严格控制客户怎么样以及何时访问单例对象。、

特点：

（1）单例类只能有一个实例；

（2）单例类必须自己创建自己的唯一实例；

（3）单例类必须给所有其他对象提供这一实例。

## 5.单例模式实现
懒汉式（线程不安全）（singleton，synchronized，volatile，getInstance）

Singleton 通过私有化构造函数，避免类在外部被实例化，而且只能通过 getInstance() 方法获取 Singleton 的唯一实例。 

```java
//懒汉式单例类.在第一次调用的时候实例化自己 
public class Singleton {
    private Singleton() {}
    private static Singleton singleton;
    //静态工厂方法 
    public static Singleton getInstance() {
         if (singleton == null) {  
             singleton = new Singleton();
         }  
        return singleton;
    }
}
```

实现线程安全的三种方式：

1.在 getInstance() 方法上加同步机制：(影响性能)

```java
public static synchronized Singleton getInstance() {
         if (singleton == null) {  
             singleton = new Singleton();
         }  
        return singleton;
}
```

2.双重检查锁定：

```java
//懒汉式单例类.在第一次调用的时候实例化自己 
public class Singleton {
    private Singleton() {}
    private volatile static Singleton singleton;
    
    public static Singleton getInstance() {
        if (singleton == null) {  
            synchronized (Singleton.class) {  
               if (singleton == null) {  
                  singleton = new Singleton(); 
               }  
            }  
        }  
        return singleton; 
    }
}
```

（1）为什么 getInstance() 方法内需要使用两个 if (singleton == null) 进行判断呢？

假设高并发下，线程A、B 都通过了第一个 if 条件。若A先抢到锁，new 了一个对象，释放锁，然后线程B再抢到锁，此时如果不做第二个 if 判断，B线程将会再 new 一个对象。使用两个 if 判断，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗。

（2）volatile 关键字的作用？

volatile 的作用主要是禁止指定重排序。

3.静态内部类：

```java
public class Singleton {  
    private Singleton (){}  
    private static class SingletonHolder {  
       private static final Singleton INSTANCE = new Singleton();  
    }  
    public static final Singleton getInstance() {  
       return SingletonHolder.INSTANCE;  
    }  
}  
```

利用了类加载机制来保证初始化 instance 时只有一个线程。

饿汉式（线程安全）

```java
//饿汉式单例类.在类初始化时，已经自行实例化 
public class Singleton {
    private Singleton() {}
    private static final Singleton single = new Singleton();
    //静态工厂方法 
    public static Singleton getInstance() {
        return single;
    }
}
```

饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。

## 6.饿汉式和懒汉式区别
（1）初始化时机与首次调用：

饿汉式是在类加载时就将单例初始化完成，保证获取实例的时候单例是已经存在的。懒汉式会延迟加载，只有在首次调用时才会实例化单例。

（2）线程安全方面：

饿汉式天生就是线程安全的，懒汉式本身是非线程安全的，需要通过额外的机制保证线程安全

## 7.策略模式[Java设计模式之行为型：策略模式_张维鹏的博客-CSDN博客](https://blog.csdn.net/a745233700/article/details/83661703)
概念：

策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。

优点：可以动态改变对象的行为；

缺点：会产生很多策略类，同时客户端必须知道所有的策略类，并自行决定使用哪一个策略类； 

## 8.策略模式实现
一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：

<!-- 这是一张图片，ocr 内容为：SALESMAN STRATEGY STRATEGY:STRATEGY + SHOW0:VOID +SALESMAN(STRATEGY STRATEGY) + SALESMANSHOW0 :VOID STRATEGYC STRATEGYA STRATEGYB + SHOW0:VOID +SHOWO:VOID SHOW0:VOID -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689601155872-1c197396-f647-4240-aded-6b629f719e92.png)

定义百货公司所有促销活动的共同接口

```java
public interface Strategy {
    void show();
}
```

定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动

```java
//为春节准备的促销活动A
public class StrategyA implements Strategy {

    public void show() {
        System.out.println("买一送一");
    }
}

//为中秋准备的促销活动B
public class StrategyB implements Strategy {

    public void show() {
        System.out.println("满200元减50元");
    }
}

//为圣诞准备的促销活动C
public class StrategyC implements Strategy {

    public void show() {
        System.out.println("满1000元加一元换购任意200元以下商品");
    }
}
```

定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员

```java
public class SalesMan {                        
    //持有抽象策略角色的引用                              
    private Strategy strategy;                 
                                               
    public SalesMan(Strategy strategy) {       
        this.strategy = strategy;              
    }                                          
                                               
    //向客户展示促销活动                                
    public void salesManShow(){                
        strategy.show();                       
    }                                          
}            
```

使用情况：

```java
public class test{
 
public static void main(String[] args) {
        SalesMan salesMan;
        salesMan = new SalesMan(new StrategyA();
        salesMan.salesManShow

        salesMan = new SalesMan(new StrategyB();
        salesMan.salesManShow
     }
}
```

## 9.责任链模式
概念：

职责链可以将请求的处理者组织成一条链，并将请求沿着链传递，如果某个处理者能够处理请求则处理，否则将该请求交由上级处理。

优点：

（1）降低耦合度，将请求的发送者和接收者解耦。

（2）增加系统的灵活性，可以动态地改变链内的成员或者修改他们的次序，允许动态地新增或者删除处理者。

（3）增强了系统的可扩展性：可以根据需要增加新的请求处理类，满足开闭原则。

缺点：

（1）不能保证每个请求都被成功处理

（2）系统性能将受到一定影响，并且可能会造成循环调用。

eg：springmvc中的拦截器，web开发中的filter过滤器。

<!-- 这是一张图片，ocr 内容为：控制层 FILTER3 FILTER1 FILTER2 DOFILTER() DOFILTER() DOFILTERO 目标方法 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689601785087-3b5d2378-9ad4-4649-9114-41cb095b7440.png)

## 10.代理模式
概念：

使用代理对象来代替对真实对象的访问，在不修改原目标对象的前提下，提供额外的功能。

## 11.代理模式实现
静态代理：（英/ˈprɒksi/）

```java
// 共同接口
public interface Subject {
    void doSomething();
}

// 真实对象
public class RealSubject implements Subject {
    @Override
    public void doSomething() {
        System.out.println("RealSubject is doing something.");
    }
}

// 代理对象
public class ProxySubject implements Subject {
    private RealSubject realSubject;

    public ProxySubject() {
        realSubject = new RealSubject();
    }

    @Override
    public void doSomething() {
        // 在调用真实对象的功能前，可以进行一些预处理操作
        System.out.println("before");

        // 调用真实对象的功能
        realSubject.doSomething();

        // 在调用真实对象的功能后，可以进行一些后处理操作
        System.out.println("after");
    }
}

public class Client {
    public static void main(String[] args) {
        // 使用代理对象来访问真实对象的功能
        Subject subject = new ProxySubject();
        subject.doSomething();
    }
}

```

动态代理：

```java
// 共同接口
public interface Subject {
    void doSomething();
}

// 真实对象
public class RealSubject implements Subject {
    @Override
    public void doSomething() {
        System.out.println("RealSubject is doing something.");
    }
}


// 代理处理器类
public class ProxyHandler implements InvocationHandler {
    private Object target;

    public ProxyHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 在调用真实对象的方法前，可以进行一些预处理操作
        System.out.println("before");

        // 调用真实对象的方法
        Object result = method.invoke(target, args);

        // 在调用真实对象的方法后，可以进行一些后处理操作
        System.out.println("after");

        return result;
    }
}



public class Client {
    public static void main(String[] args) {
        // 创建真实对象
        Subject realSubject = new RealSubject();

        // 创建代理处理器
        ProxyHandler proxyHandler = new ProxyHandler(realSubject);

        // 创建代理对象
        Subject proxySubject = (Subject) Proxy.newProxyInstance(
            Subject.class.getClassLoader(),
            new Class[] { Subject.class },
            proxyHandler
        );

        // 使用代理对象来访问真实对象的功能
        proxySubject.doSomething();
    }
}


```

## 1.Spring中使用了哪些设计模式？
1.单例模式：Spring容器管理的Bean默认是单例的，每个Bean实例在整个应用程序中只存在一个，以节省资源和避免重复创建。

2.工厂方法模式：Spring中的Bean工厂就是工厂方法模式，通过工厂方法创建Bean对象，实现了对象的创建和使用解耦。

3.代理模式：Spring AOP中使用代理模式来实现动态代理，实现了对目标对象的控制和增强。

4.策略模式：Spring中的事务管理器使用了策略模式，支持多种事务管理策略的切换。

## 2.MyBatis中使用了哪些设计模式？
1.工厂方法模式：MyBatis中的SqlSessionFactory就是一个工厂方法，它负责创建SqlSession对象，将数据库访问的过程封装起来，使客户端代码不需要关心具体的创建过程。

2.代理模式：MyBatis使用动态代理来实现Mapper接口的代理对象。在MyBatis中，Mapper接口定义了数据库操作的方法，而其实现由MyBatis在运行时动态生成代理类来完成。

3.策略模式：MyBatis中的ResultSetHandler就是策略模式的应用。ResultSetHandler定义了数据库结果集的处理策略，而具体的处理逻辑由不同的实现类来实现。

## 3.JDK 中有哪些设计模式
1.单例模式：java.lang.Runtime 类是一个典型的单例类，它表示Java运行时环境，通过 Runtime.getRuntime() 方法获取单例实例。

2.工厂方法模式：java.util.Calendar 类通过 getInstance() 方法获取日历实例，隐藏了具体的实例创建过程，使得客户端代码不需要关心具体实现类。

## 4.设计模式总结
##### 1.工厂模式：
概念：

在创建对象时，不会对客户端暴露对象的创建逻辑，而是通过使用共同的接口来创建对象。

1.简单工厂：

增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。

2.工厂方法：

每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。

3.抽象工厂：

当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。

##### 2.单例模式：
概念：

确保系统中某个类只有一个实例，该类自行实例化并向整个系统提供这个实例的公共访问点。

优点：

1.系统中只存在一个共用的实例对象，无需频繁创建和销毁对象，节约了系统资源，提高系统的性能。

2.可以严格控制客户怎么样以及何时访问单例对象。

特点：

（1）单例类只能有一个实例；

（2）单例类必须自己创建自己的唯一实例；

（3）单例类必须给所有其他对象提供这一实例。

##### 3.策略模式：
概念：

定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。

优点：可以动态改变对象的行为；

缺点：会产生很多策略类，同时客户端必须知道所有的策略类，并自行决定使用哪一个策略类； 

##### 4.责任链模式
概念：

将多个处理对象连成一条责任链，依次处理请求，直到请求被处理或到达责任链的末尾。

优点：

（1）降低耦合度，将请求的发送者和接收者解耦。

（2）增加系统的灵活性，可以动态地改变链内的成员或者修改他们的次序，允许动态地新增或者删除处理者。

（3）增强了系统的可扩展性：可以根据需要增加新的请求处理类，满足开闭原则。

缺点：

（1）不能保证每个请求都被成功处理

（2）系统性能将受到一定影响，并且可能会造成循环调用。

##### 5.代理模式：
概念：

使用代理对象来代替对真实对象的访问，在不修改原目标对象的前提下，提供额外的功能。



## 5.其他设计模式
##### 1.模板方法
模板方法模式是指定义一个算法骨架，将具体内容延迟到子类去实现。

eg：上班打卡----工作---下班打卡

##### 2.观察者模式
观察者模式是定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式。

##### 3.装饰器模式
装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。

##### 4.适配器模式
适配器模式是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无

法一起工作的两个类能够在一起工作。

##### 5.享元模式
当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可

以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内

存中对象的数量，起到节省内存的目的。

区别：

单例模式是创建型模式，重在只能有一个对象。而享元模式是结构型模式，重在节约内存使

用，提升程序性能。





