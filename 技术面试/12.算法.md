# 0.使用
数组转list：Arrays.asList(strs)

数组转stream：Arrays.stream(copy)

list转数组：list.toArray(new String[list.size()])

# 1.排序
<!-- 这是一张图片，ocr 内容为：排序算法 最好情况 稳定性 排序方式 平均时间复杂度 空间复杂度 最坏情况 (,) ) (U)O (,)O N 0(1) 稳定 IN-PLACE 冒泡排序 IN-PLACE 选择排序 O(N     O(N 2) 不稳定 0(1) O(N 3) 稳定 O(N 2) 插入排序 ()).) (N)( O(1) IN-PLACE OLN LOG ? N ) OLN LOG ? N ) IN-PLACE 希尔排序 不稳定 O(N LOG N) 0(1) 稳定 O (N LOG N) (N)O O(N LOG N) 归并排序 O(N LOG N) OUT-PLACE 快速排序 O(LOG N) O(N2) O(N LOG N) O(N LOG N) IN-PLACE 不稳定 O (N LOG N) IN-PLACE 堆排序 不稳定 0(1) O (N LOG N) O(N LOG N) OLN+K) 计数排序 稳定 OUT-PLACE O(K) O(N + K) O(N + K) O(N + K) O(N+K) 稳定 桶排序 OUT-PLACE O(N 2) O(N+K) 基数排序 O(N X K) 稳定 O(N + K) O(N X K) O(N X K) OUT-PLACE ND -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689669297594-c724825d-8580-4428-bb77-f872fa89e23a.png)

不稳定：选择、希尔、快速、堆

## 1.冒泡排序
要求

● 能够用自己语言描述冒泡排序算法

● 能够手写冒泡排序代码

● 了解一些冒泡排序的优化手段

算法描述

1. 依次比较数组中相邻两个元素大小，若 a[j] > a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后

2. 重复以上步骤，直到整个数组有序

```java
int[] arr = new int[]{1,2,3,7,2,15,90,0};
int n = arr.length;
for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            // 交换arr[j]和arr[j+1]
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
Arrays.stream(arr).forEach(System.out::println);
```

## 2.选择排序
要求

● 能够用自己语言描述选择排序算法

● 能够比较选择排序与冒泡排序

● 理解非稳定排序与稳定排序

算法描述

1.  将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集 

2.  重复以上步骤，直到整个数组有序

```java
for (int i = 0; i < n -1; i++) {
    for (int j = i + 1; j < n; j++) {
        if(arr[i] > arr[j]){
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
}
```

## 3.二分查找
要求

● 能够用自己语言描述二分查找算法

● 能够手写二分查找代码

● 能够解答一些变化后的考法

算法描述

1.  前提：有已排序数组 A（假设已经做好） 

2.  定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步） 

3.  获取中间索引 M = Floor((L+R) /2) 

4.  中间索引的值  A[M] 与待搜索的值 T 进行比较

① A[M] == T 表示找到，返回中间索引

② A[M] > T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找

③ A[M] < T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找 

5.  当 L > R 时，表示没有找到，应结束循环 

```java
public static int binarySearch(int[] a, int t) {
    int l = 0, r = a.length - 1, m;
    while (l <= r) {
        m = (l + r) / 2;
        if (a[m] == t) {
            return m;
        } else if (a[m] > t) {
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}
```

## 4.插入排序
要求

● 能够用自己语言描述插入排序算法

● 能够比较插入排序与选择排序

算法描述

1.  将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序） 

2.  重复以上步骤，直到整个数组有序 

```java
for (int i = 1; i < n; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}
```

## 5.希尔排序
要求

● 能够用自己语言描述希尔排序算法

算法描述

1.  首先选取一个间隙序列，如 (n/2，n/4 … 1)，n 为数组长度 

2.  每一轮将间隙相等的元素视为一组，对组内元素进行插入排序，目的有二

① 少量元素插入排序速度很快

② 让组内值较大的元素更快地移动到后方 

3.  当间隙逐渐减少，直至为 1 时，即可完成排序



<!-- 这是一张图片，ocr 内容为：HTTPS://WWW.GUOYAOHUA.COM 原始数组长度为10,如下所示: 5 8 6 9 3 初始增量设为GAP:LENGTH/2:5,整个数组会被分为5个子数组 分别为:[6,8][4,3][5,0][7,9][2,1] 5 0 7 3 8 4 2 6 分别对这5组进行直接插入排序,可以看到各组内部元素已有序 之后缩小增量为GAP:5/2:2,数组会被重新分为2个子数组 分别为:[6,0,1,4,9][3,7,8,5,2] 8 5 3 4 对以上两组数组再分别进行插入排序,数组变得更加有序 我们再缩小增量为GAP:2/2:1,此时即为常规插入排序 整个数组为-组:[0,2,1,3,4,5,6,7,9,8] 9 5 2 4 6 3 1 8 可以看出数组已基本有序 此时插入排序算法仅需少次微调即可完成排序 7 3 0 5 2 4 6 8 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690879980037-560cd48e-839c-418e-ba23-425373e09a8e.png)

## 6.快速排序
要求

● 能够用自己语言描述快速排序算法

● 掌握手写单边循环、双边循环代码之一

● 能够说明快排特点

● 了解洛穆托与霍尔两种分区方案的性能比较

算法描述

1. 每一轮排序选择一个基准点（pivot）进行分区 

  a. 让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区

  b. 当分区完成时，基准点元素的位置就是其最终位置

2. 在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （divide-and-conquer）

3. 从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案



# 2.二分查找
<font style="color:rgb(44, 62, 80);">给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</font>

<!-- 这是一张图片，ocr 内容为：示例1: 输入: : [-1,0,3,5,9,12], TARGET : 9 1 NUMS 输出:4 2 解释:9出现在 中并且下标为4 3 NUMS 示例2: 输入: 1 :[-1,0,3,5,9,12], TARGET ; 2 川 NUMS 输出:-1 2 解释:2不存在 中因此返回-1 3 NUMS -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689684033578-3ff0c595-81bc-4a7d-97fd-67ab73b37db2.png)

```java
public static int binarySearch(int[] a, int t) {
        int l = 0, r = a.length - 1, m;
        while (l <= r) {
            m = (l + r) / 2;
            if (a[m] == t) {
                return m;
            } else if (a[m] > t) {
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        return -1;
    }
```

# 3.双指针
用于在数组或链表等数据结构中，通常用于优化问题，减少不必要的遍历或循环，从而提高算法的效率。

## 27.移除元素
给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

<!-- 这是一张图片，ocr 内容为：1:给定NUMS三I3,2.31.3,VAL-3,函数应该返回新的长度2,并且NUMS中的前两个元素均为2.你不 示例 需要考虑数组中超出新长度后面的元素. 示例2:给定HUMS-(0.1.2.23.042].VAL-2,函数应该返回新的长度5,并且HUMS中的前五个元素为0.1 3,0, 4. 你不需要考虑数组中超出新长度后面的元素. -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689684622018-a0c49b49-d176-4a16-a0b6-9afa408377d1.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/gif/34358440/1689685220205-ca6b3a7c-52f3-4107-adf2-92978350b3f3.gif)

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // 快慢指针
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }
}
```

## 977.有序数组的平方
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

<!-- 这是一张图片，ocr 内容为：示例1:输入:NUMS-[4-1.0.3,101输出:[0.16,16,16,100]解释:平方后,数组变为(16,100),排序 后,数组变为[0,1,9,16,100] 示例2:输入:NUMS-[-7 -[-7,-3,2,3,11]输出:[4,9,9,49,121] -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689688296921-38b06005-9b1f-4e6a-8757-96b19ec852c3.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/gif/34358440/1689688270227-44fc7e37-f6b2-4337-805d-651d038eda56.gif)

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int right = nums.length - 1;
        int left = 0;
        int[] result = new int[nums.length];
        int index = result.length - 1;
        while (left <= right) {
            if (nums[left] * nums[left] > nums[right] * nums[right]) {
                // 正数的相对位置是不变的， 需要调整的是负数平方后的相对位置
                result[index--] = nums[left] * nums[left];
                left++;
            } else {
                result[index--] = nums[right] * nums[right];
                right--;
            }
        }
        return result;
    }
}
```

## 206.反转链表
反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/gif/34358440/1689690658399-3f0f734e-5618-4bea-8ccf-f90472b416fe.gif)

```java
// 双指针
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode cur = head;
        ListNode temp = null;
        while (cur != null) {
            temp = cur.next;// 保存下一个节点
            cur.next = prev;
            prev = cur;
            cur = temp;
        }
        return prev;
    }
}
```

## 344.反转字符串
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

<!-- 这是一张图片，ocr 内容为：示例1: 输入:["H","E","L","O"] 输出:["O""L","L","E"] 示例2: 输入:["H","A","N","N","A","H"] 输出:["H","A","N","N","A","H"] -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689691593194-e654b19a-dca9-4ea6-8678-4b6274f6a0a1.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/gif/34358440/1689691559178-7f7e3abe-8183-45ec-9840-dafac10d0d06.gif)

```java
// 第二种方法用temp来交换数值更多人容易理解些
class Solution {
    public void reverseString(char[] s) {
        int l = 0;
        int r = s.length - 1;
        while(l < r){
            char temp = s[l];
            s[l] = s[r];
            s[r] = temp;
            l++;
            r--;
        }
    }
}
```

# 4.链表
<!-- 这是一张图片，ocr 内容为：查询(时间 插入/删除(时 适用场景 复杂度) 间复杂度) 数据量固定,频繁查 数组 O(N) 0(1) 询,较少增删 链表 数据量不固定,频繁增 O(N) 0(1) 删,较少查询 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689689696527-be76c173-54b6-452d-877d-386d4bdd409c.png)

```java
public class ListNode {
    // 结点的值
    int val;

    // 下一个结点
    ListNode next;

    // 节点的构造函数(无参)
    public ListNode() {
    }

    // 节点的构造函数(有一个参数)
    public ListNode(int val) {
        this.val = val;
    }

    // 节点的构造函数(有两个参数)
    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

移除链表元素

```java
/**
 * 添加虚节点方式
 * 时间复杂度 O(n)
 * 空间复杂度 O(1)
 * @param head
 * @param val
 * @return
 */
public ListNode removeElements(ListNode head, int val) {
    if (head == null) {
        return head;
    }
    // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作
    ListNode dummy = new ListNode(-1, head);
    ListNode pre = dummy;
    ListNode cur = head;
    while (cur != null) {
        if (cur.val == val) {
            pre.next = cur.next;
        } else {
            pre = cur;
        }
        cur = cur.next;
    }
    return dummy.next;
}
/**
 * 不添加虚拟节点方式
 * 时间复杂度 O(n)
 * 空间复杂度 O(1)
 * @param head
 * @param val
 * @return
 */
public ListNode removeElements(ListNode head, int val) {
    while (head != null && head.val == val) {
        head = head.next;
    }
    // 已经为null，提前退出
    if (head == null) {
        return head;
    }
    // 已确定当前head.val != val
    ListNode pre = head;
    ListNode cur = head.next;
    while (cur != null) {
        if (cur.val == val) {
            pre.next = cur.next;
        } else {
            pre = cur;
        }
        cur = cur.next;
    }
    return head;
}
/**
 * 不添加虚拟节点and pre Node方式
 * 时间复杂度 O(n)
 * 空间复杂度 O(1)
 * @param head
 * @param val
 * @return
 */
public ListNode removeElements(ListNode head, int val) {
    while(head!=null && head.val==val){
        head = head.next;
    }
    ListNode curr = head;
    while(curr!=null){
        while(curr.next!=null && curr.next.val == val){
            curr.next = curr.next.next;
        }
        curr = curr.next;
    }
    return head;
}
```

# 5.递归法
## 206.反转链表
题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

```java
// 递归 
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }

    private ListNode reverse(ListNode prev, ListNode cur) {
        if (cur == null) {
            return prev;
        }
        ListNode temp = null;
        temp = cur.next;// 先保存下一个节点
        cur.next = prev;// 反转
        // 更新prev、cur位置
        // prev = cur;
        // cur = temp;
        return reverse(cur, temp);
    }
}
```

## 509. 斐波那契数列
斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。

<!-- 这是一张图片，ocr 内容为：示例1: 输入:2 输出:1 解释:F(2)FF(1)+F(0)-1+01 示例2: 输入: 输出:2 解释:F(3)F(2)+F(1)-1)-1+1+2 示例3: 输入:4 输出:3 解释:F(4)-F(3)+F(2)2+2+133 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689737084560-64c671d7-8a9d-4704-9366-fdce1648fb57.png)

```java
class Solution {
    public int fib(int n) {
    if (n < 2) return n;
    return fib(n - 1) + fib(n - 2);
	}
}
```

# 7.贪心
贪心算法中，每一步都选择当前最优解，希望通过一系列局部最优的选择最终达到全局最优。

应用举例：

找零钱问题： 在付款时，找零钱的问题可以使用贪心算法。从大面额钞票开始，选择最大的钞票直到满足找零的金额。

## 455.分发饼干
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

<!-- 这是一张图片，ocr 内容为：示例1: 输入:G[1,2,3],S[1,1] ,输出:1解释你有三个孩子和两块小饼干,3个孩子的胃口值分别是:1.2.3.虽然你有两块小饼干,由 于他们的尺寸都是1,你只能让胃口值是1的孩子满足.所以你应该输出1. 示例2: 输入:G-[1,2],S[1,2,3] 输出:2 解释你有两个孩子和三块小饼干,2个孩子的胃口值分别是1.2.你拥有的饼干数量和尺寸都足以让所 有孩子满足.所以你应该输出2. -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689734427285-8304b48e-9097-4a3b-acb3-b11d439a6e7f.png)

<!-- 这是一张图片，ocr 内容为：饼干: 1 5 9 3 满足 满足 满足 小孩: 2 7 10 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1692772373366-14a9a174-9d12-4a85-9966-a0f774a42496.png)

然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。

```java
class Solution {
    // 思路2：优先考虑胃口，先喂饱大胃口
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int count = 0;
        int start = s.length - 1;
        // 遍历胃口
        for (int index = g.length - 1; index >= 0; index--) {
            if(start >= 0 && g[index] <= s[start]) {
                start--;
                count++;
            }
        }
        return count;
    }
}
```

## 860.柠檬水找零
在柠檬水摊上，每一杯柠檬水的售价为 5 美元。



顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

<!-- 这是一张图片，ocr 内容为：示例1: 输入 [5,5,5,10,20] 输出: TRUE 解释: 前3位顾客那里,我们按顺序收取3张5美元的钞票. 9第4位顾客那里,我们收取一张10美元的钞票,并返还5美元. 9第5位顾客那里,我们找还一张10美元的钞票和一张5美元的钞票. 由于所有客户都得到了正确的找零,所以我们输出T TRUE. 示例2: 输入:[ [5,5,10] 输出:TRUE 示例3: 输入:[10,10] 输出:FALSE -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689735256488-a52c94e0-af7e-469c-91cc-7bd118467ced.png)

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0;
        int ten = 0;

        for (int i = 0; i < bills.length; i++) {
            if (bills[i] == 5) {
                five++;
            } else if (bills[i] == 10) {
                five--;
                ten++;
            } else if (bills[i] == 20) {
                if (ten > 0) {
                    ten--;
                    five--;
                } else {
                    five -= 3;
                }
            }
            if (five < 0 || ten < 0) return false;
        }
        
        return true;
    }
}
```

# 8.动态规划
它将问题分解为子问题，并通过解决子问题的方式构建原问题的解

## 509. 斐波那契数
斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。

<!-- 这是一张图片，ocr 内容为：示例1: 输入:2 输出:1 解释:F(2)F(1)+F(0)-1+01+0-1 示例2: 输入:3 输出:2 解释:F(3)F(2)+F(1)1+1+1+2 示例3: 输入:4 输出:3 解释:F(4)F(3)+F(2)2)2+133 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689736811551-0ad201c8-b82c-43d8-a68f-561e635413ea.png)

```java
//非压缩状态的版本
class Solution {
    public int fib(int n) {
        if (n <= 1) return n;             
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int index = 2; index <= n; index++){
            dp[index] = dp[index - 1] + dp[index - 2];
        }
        return dp[n];
    }
}
```

```java
class Solution {
    public int fib(int n) {
        if (n < 2) return n;
        int a = 0, b = 1, c = 0;
        for (int i = 1; i < n; i++) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
}
```

## 70. 爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

<!-- 这是一张图片，ocr 内容为：示例1: 输入:2 输出:2 解释:有两种方法可以爬到楼顶. 1阶+1阶 2阶 示例2: 输入:3 输出: 3 解释:有三种方法可以爬到楼顶. 01阶+1阶+1阶 01阶+2阶 2阶+1阶 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690939200718-f68c34e7-c5b8-42f9-ac96-db9b6398e760.png)

```java
// 常规方式
public int climbStairs(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
	dp[2] = 2;
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

```java
// 用变量记录代替数组
class Solution {
    public int climbStairs(int n) {
        if(n <= 2) return n;
        int a = 1, b = 2, sum = 0;

        for(int i = 3; i <= n; i++){
            sum = a + b;  // f(i - 1) + f(i - 2)
            a = b;        // 记录f(i - 1)，即下一轮的f(i - 2)
            b = sum;      // 记录f(i)，即下一轮的f(i - 1)
        }
        return b;
    }
}
```

## 62.不同路径
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

<!-- 这是一张图片，ocr 内容为：示例1: START FINISH -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689748607565-d9bff35e-a042-4858-947e-590f84e9d9d8.png)

<!-- 这是一张图片，ocr 内容为：输入:M-3,N-7 输出:28 示例2: 输入:M2,N三3 输出:3 解释:从左上角开始,总共有3条路径可以到达右下角. 1.向右->向右->向下 2.向右->向下->向右 3.向下->向右->向右 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689748866527-8fbadaa3-8398-4743-8e83-b78a555c5dff.png)

```java
/**
 * 1. 确定dp数组下标含义 dp[i][j] 到每一个坐标可能的路径种类
 * 2. 递推公式 dp[i][j] = dp[i-1][j] dp[i][j-1]
 * 3. 初始化 dp[i][0]=1 dp[0][i]=1 初始化横竖就可
 * 4. 遍历顺序 一行一行遍历
 * 5. 推导结果 。。。。。。。。
 *
 * @param m
 * @param n
 * @return
 */
public static int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    //初始化
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int i = 0; i < n; i++) {
        dp[0][i] = 1;
    }

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j]+dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
}
```



