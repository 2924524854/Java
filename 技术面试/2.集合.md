## <!-- 这是一张图片，ocr 内容为：VECTOR  数组结构,线程安全 -ARRAYLIST数组结构,非线程安全 LIST有序,可重复 COLLECTION LINKEDLIST链表结构,非线程安全 单列集合 LINKEDHASHSET哈希表和链表结构 HASHSET 哈希表结构 SET无序,唯 TREESET 红黑树结构 集合框架 HASHTABLE哈希表结构,线程安全 PROPERTIES LINKEDHASHMAP 哈希表和链表结构 HASHMAP 哈希表结构,非线程安全 MAP 双列集合 CONCURRENTHASHMAP 哈希表结构,线程安全 红黑树结构 TREEMAP -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689168198590-f3cd5691-a608-425d-9cf1-dde475a954ae.png)
## 1.ArrayList底层的实现原理是什么、
<!-- 这是一张图片，ocr 内容为：PUBLIC ARRAYLIST(INITIALCAPACITY) 带初始化容量的构造函数 PUBLIC ARRAYLIST(COLLECTION<?EXTENDS E> C){ OBJECT[A C.TOARRAY(); IF(INITIALCAPACITY>0) THIS.ELEMENTDATA NEW OBJECTLINITIALCAPACITY]; IF(SIZEALENGTH)! IF (C.GETCLASS() ARRAYLISTCLASS) ELSE IF(INITIALCAPACITY ELEMENTDATA  THIS.ELEMENTDATAEMPTY_ELEMENTDATA; ELSE ELSE ELEMENTDATA - ARRAYS.COPYOF(A,SIZE,OBJECTL.CLASS); THROW NEW LLLEGALARGUMENTEXCEPTION("LLEGAL CAPACITY:"+ INITIALCAPACITY); BELSEL / REPLACE WITH EMPTY ARRAY. ELEMENTDATA EMPTY ELEMENTDATA; * CONSTRUCTS AN EMPTY LIST WITH AN INITIAL CAPACITY OF TEN. 了 PUBLICARRAYLIST()无参构造函数,默认创建空集合 将COLLECTION对象转换成数组,然后将数组的地址的 THIS ELEMENTDATA - DEFAULTCAPACITY EMPTY ELEMENTDATA; 赋给ELEMENTDATA -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689765881450-74c36600-51a1-4cc0-bcaa-0d7518998913.png)

<!-- 这是一张图片，ocr 内容为：PUBLIC BOOLEAN ADD(E E) 计算容量 DEFAULT_CAPACITY10 ENSURECAPACITYLNTERNAL(SIZE+1); S ELEMENTDATA SIZE++]三 RETURN TRUE; RETURN MATH.MAX(DEFAULT_CAPACITY,MINCAPACITY); RETURN MINCAPACITY; 确保内部容量 PRIVATE VOID ENSURECAPACITYLNTERNAL(INT MINCAPACITY) { ENSUREEXPLICITCAPACITY(CALCULATECAPACITY(ELEMENTDATA,MINCAPACITY) 扩容方法 10 PRIVATE VOID GROW(INT MINCAPACITY) 10 / OVERFLOW-CONSCIOUS CODE INT OLDCAPACITY ELEMENTDATA.LENGTH; PRIVATE VOID ENSUREEXPLICITCAPACITY(INT MINCAPACITY) INT NEWCAPACITY>OLDCAPACITY+(OLDCAPACITY>>>>1):增加原来容量的1.5倍 MODCOUNT+; IF(NEWCAPACITY-MINCAPACITY < 0) 如果大于0,说明容量不够,需扩容 第一次初始化数组长度 //OVERFLOW-CONSCIOUS CODE NEWCAPACITY MINCAPACITY; IF (MINCAPACITY - ELEMENTDATA.LENGTH >0) IF(NEWCAPACITY-MAX_ARRAY_SIZE>0) NEWCAPACITY HUGECAPACITY(MINCAPACITY); GROW(MINCAPACITY); IL MINCAPACITY IS USUALLY CLOSE TO SIZE, SO THIS IS A WIN: ELEMENTDATA -ARRAYS.COPYOF(ELEMENTDATA,NEWCAPACITY):数组拷贝 了 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689766202705-d436b026-bdf7-4038-9ce2-4ce0077339f7.png)

ArrayList内部维护一个对象数组，用于存储元素。当ArrayList被创建时，会初始化一个默认大小的数组。当数组不够存储新添加的元素时，ArrayList会动态地创建一个更大的数组，将原有元素复制到新数组中。

1.底层数据结构

ArrayList底层是用动态的数组实现的

2.初始容量

ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10

3.扩容逻辑     

ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组

4.添加逻辑

◆确保数组已使用长度(size)加1之后足够存下下一个数据

◆计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用gow方法扩容（原来的1.5倍）50%

◆确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。 

## 2.数组和List之间的转换
1. 数组转list：Arrays.asList转换list之后，如果修改了数组的内容，<font style="color:#DF2A3F;">list会受影响</font>，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址。

2. list转数组：list用了toArray转数组后，如果修改了list内容，<font style="color:#DF2A3F;">数组不会影响</font>，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响。

## 3.ArrayList 和 LinkedList 的区别是什么？
1.它们的底层实现不同：ArrayList 是基于动态数组的数据结构，而 LinkedList 是基于链表的数据结构。

2.访问性能不同： ArrayList查找的时间复杂度是  O(1) ，而 LinkedList 的时间复杂度为 O(n)，因为它需要遍历整个链表。

3.插入和删除性能不同： LinkedList 的插入和删除操作时间复杂度为 O(1)，而 ArrayList 的时间复杂度为 O(n)。

4.内存空间占用：ArrayList底层是数组，内存连续，节省内存；LinkedList是双向链表更占用内存。

## 3.红黑树的特性
1.节点要么是红色,要么是黑色

2.根节点是黑色

3.叶子节点都是黑色的空节点

4.红黑树中红色节点的子节点都是黑色

5.从根节点到叶节点必须包含相同数目的黑色节点。

<!-- 这是一张图片，ocr 内容为：55 在添加或删除节点 些性质会发生旋转 80 38 76 25 88 46 17 72 50 33 NULL NULL NULL NULL NULL NULL NULL NULL NULL NULL NULL NULL -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689164304235-a9291783-7c0b-4bd2-9242-f8dc669b6e85.png)

## 4. 散列冲突
 散列冲突又称哈希冲突，哈希碰撞，指多个key映射到同一个数组下标位置

 方法：链表法（拉链）：hash冲突后的元素都放到相同槽位对应的链表中或红黑树中

<!-- 这是一张图片，ocr 内容为：散列冲突-链表法 (拉链) 2023ZHBJ0875 数组 2023ZHBJ0876 1 2023ZHBJ0877 散列函数 2 2023ZHBJ0878 3 2023ZHBJ0879 4 HASH(KEY) 2023ZHBJ0880 2023ZHBJ0881 5 2023ZHBJ0882 6 2023ZHBJ0883 将链表法中的链表改造红黑树还有一个非常重要的原因,可以防止DDOS攻击 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689164603396-4d66196a-d3a3-4c60-b185-12ef7abbbe6e.png)

## 5.HashMap实现原理
1，底层使用hash表数据结构，即数组+（链表 | 红黑树）

2，添加数据时，计算key的值确定元素在数组中的下标key相同则替换，不同则存入链表或红黑树中

3，获取数据通过key的hash计算数组下标获取元素

<!-- 这是一张图片，ocr 内容为：26 63 25 9 13 11 62 15 12 14 链表的长度大于8且数组长度大于64 转换为红黑树 NULL NULL NULL -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689164850952-1536b32f-98b7-4545-8b33-1d898a85c61f.png)

## 6. HashMap的jdk1.7和jdk1.8有什么区别  
1.JDK1.8之前采用的拉链法，数组+链表

2.JDK1.8之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64则会从链表转化为红黑树

## 7.HashMap的put方法的具体流程
<!-- 这是一张图片，ocr 内容为：添加数据流程图 TABLE[I是否 在红黑树中添加 开始 是红黑树 否 否 TABLE是否为空 遍历链表 初始化长度16的数组 否,非第1次 链尾插入结点 根据KEY计算数 KEY是否存在 RESIZE() 否 组的索引值 否 KEY是否存在 是 是 是 链表长度是 直接覆盖VALUE 转换为红黑树 否大于8 TABLE[I] 直接覆盖VALUE 是 直接插入 是 否 ++SIZE> 结束 THRESHOLD THRESHOLD数组长度*0.75 京奶棉体 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689165593996-f2146f30-20a0-4127-ae3a-58298fb7a1e2.png)

1. 判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）

2. 根据键值key计算hash值得到数组索引

3. 判断table[i]==null，条件成立，直接新建节点添加

4. 如果table[i]==null ,不成立

4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value

4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对

4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value

5. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容

## 8.HashMap的扩容机制
<!-- 这是一张图片，ocr 内容为：否 设置数组容量为16 结束 新建数组 开始 OLDCAP>0 设置扩容阈值12 是 遍历旧数组 新建数组 NEWCAP-OLDCAP* 2 是 E.NEXT 三 添加到新数组中 NULL NEWTABU+OLDCAP]-OLDTABLI] 是 是否是红 红黑树添加 黑树 否 否 (E.HASH&OLDCAP) 遍历链表 NEWTABU] OLDTABU] 拆分链表 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689166056568-0f14e929-f257-432a-af83-39fdc700dc14.png)

1.在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）

2.每次扩容的时候，都是扩容之前容量的2倍；

3.扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中

1.没有hash冲突的节点，则直接使用 e.hash & (newCap - 1) 计算新数组的索引位置

2.如果是红黑树，走红黑树的添加

3.如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash & oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上



## 9. hashMap的寻址算法
<!-- 这是一张图片，ocr 内容为：PUBLIC V PUT(K KEY,V VALUE) N PUTVAL(HASH(KEY), KEY,VALUE,FALSE,TRUE); RETURN P STATIC FINAL INT HASH(OBJECT KEY) 扰动算法,是HASH值更加均匀,减少HASH冲突 INT H RETURN (KEY - NULL) ?0:(H - KEY.HASHCODE()) FINAL V PUTVAL(INT HASH,KEY, VALUE,BOOLEAN ONLYLFABSENT, BOOLEAN EVICT) (N-1)&HASH:得到数组中的索引,代替取模,性能更好 IF((PTABLI(N - 1)&HASH)&HASH) 数组长度必须是2的N次幂 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689166980685-74cffe60-fcd5-4cdb-817f-7e96aa50241d.png)

1.计算对象的 hashCode()

2. 再进行调用 hash() 方法进行二次哈希， hashcode值右移16位再异或运算，让哈希分布更为均匀

3.最后 (n – 1) & hash 得到索引

## 10.为什么HashMap的数组长度一定是2的次幂
1.计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模

2.扩容时重新计算索引效率更高： hash & oldCap == 0 的元素留在原来位置 ，

否则新位置 = 旧位置 + oldCap

## 11.hashmap在1.7情况下的多线程死循环问题
jdk7的的数据结构是：数组+链表

在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环

JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置

## 12.HashMap与HashSet的区别？  
1.HashSet 实现了 Set 接口，只存储对象；HashMap 实现了 Map 接口，用于存储键值对。

2.HashSet 底层是用 HashMap 存储的，HashSet 将值保存到 HashMap 的 Key 里面了。（而HashMap的value部分统一使用一个对象来占位，以节省内存空间）

3.HashSet 不允许集合中有重复的值，而 HashMap 键不能重复，值可以重复。

## 13.HashMap与HashTable（散列表）的区别
<!-- 这是一张图片，ocr 内容为：2023ZHBJ0875 数组 2023ZHBJ0876 1 2023ZHBJ0877 散列函数 2 2023ZHBJ0878 3 2023ZHBJ0879 4 HASH(KEY) 2023ZHBJ0880 2023ZHBJ0881 5 2023ZHBJ0882 9 2023ZHBJ0883 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689168110683-87ca8575-a725-425f-bdf3-2d2328941d4b.png)

1.Hashtable 是线程安全的，而 HashMap 是非线程安全的。

2.HashMap允许 key 和 value 为 null，而 Hashtable 不允许存储 null 键和 null 值。

3.Hashtable 使用了 synchronized 给整个方法添加了锁，所以它的性能不如 HashMap。

在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类

## 0________________________________________________________________
## 1.集合框架底层数据结构总结
 List

ArrayList：动态数组

LinkedList：双向链表

 Set

HashSet: HashMap 

LinkedHashSet:  LinkedHashMap 

TreeSet: 红黑树

Map

HashMap：数组+链表+红黑树

LinkedHashMap：增加了一条双向链表

Hashtable：数组+链表

TreeMap：红黑树

## 2.ArrayList 和 Array（数组）的区别？
1.ArrayList 内部基于动态数组实现，可以动态地扩容，比数组使用起来更加灵活。

2.ArrayList 中只能存储对象。对于基本类型数据，需要使用其对应的包装类。

3.ArrayList创建时不需要指定大小，而数组创建时必须指定大小。

## 3.ArrayList 和 Vector 的区别?
ArrayList 和 Vector 实现了 List 接口。

1.Vector 是线程安全的，而 ArrayList 不是

2.由于 Vector 是线程安全的，所以它的性能通常比 ArrayList 差。

3.当容量不足时，ArrayList 默认会增加 50% 的容量，而 Vector 会将容量翻倍。

## 2.比较 HashSet、LinkedHashSet 和 TreeSet 
1. 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。

2.HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。

## 5.LinkedHashMap 和 HashMap 有什么区别？
LinkedHashMap 内部维护了一个双向链表，用于记录元素的插入顺序。因此LinkedHashMap 的插入性能比 HashMap 低，但它提供了按照插入顺序遍历元素的功能。

## 4.HashMap 为什么线程不安全？
JDK 1.8 后，在 HashMap 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 HashMap 的 put 操作会导致线程不安全，具体来说会有数据覆盖的风险。

举个例子：

1.两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。

2.不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。

3.随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。

