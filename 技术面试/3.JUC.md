# 1.线程的基础知识：
## 1.进程和线程的区别？
1.进程是资源分配的最小单位，线程是 CPU 调度的最小单位。

2.进程是指正在运行的一个程序的实例，线程是进程中的一个执行单元，它是比进程更小的能独立运行的基本单位。<font style="color:#DF2A3F;"></font>

## 2.并发与并行的区别
并发：两个及两个以上的作业在同一时间段内执行。

并行：两个及两个以上的作业在同一时刻 执行。

## 3.创建线程的方式有哪些？
 1.继承Thread类

 	2.实现runnable接口

 3.实现Callable接口（英/ˈkɔːləbl/）

	3.线程池创建线程

```java
public class MyExecutors implements Runnable{

    @Override
    public void run() {
        System.out.println("MyRunnable...run...");
    }

    public static void main(String[] args) {

        // 创建线程池对象
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        threadPool.submit(new MyExecutors()) ;

        // 关闭线程池
        threadPool.shutdown();
    }
}
```

## 4.线程的 run()和 start()有什么区别？
1.start(): 用来启动线程，通过该线程调用run方法。start方法只能被调用1次。

2.run(): 封装了要被线程执行的代码，可以被调用多次。

## 5.线程包括哪些状态
<!-- 这是一张图片，ocr 内容为：无法获得锁 获得锁 有执行资格 没有执行权 阻塞(BLOCKED) NOTIFYO WAIT() 有执行资格 没有执行权 等待 (WAITING) SLEEP(50) 到时间了 有执行资格 没有执行权 计时等待(TIMED_WAITING) 抢到CPU执行权 START() 线程死亡 有执行资格 有执行资格 创建线程对象 没有执行权 变成垃圾 有执行权 其他线程抢走了CPU执行权 运行 就绪 死亡 (TERMINATED) 新建(NEW) 可执行(RUNNABLE) -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689216594770-6cd16014-1d6c-48fe-a244-d8686bd38510.png)

1.当一个线程对象被创建，但还未调用 start 方法时处于新建状态

2.调用了 start 方法，就会由新建进入可运行

## 6.新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？
用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成，该线程再继续执行。

```java
public class JoinTest {

    public static void main(String[] args) {

        // 创建线程对象
        Thread t1 = new Thread(() -> {
            System.out.println("t1");
        }) ;

        Thread t2 = new Thread(() -> {
            try {
                t1.join();                          // 加入线程t1,只有t1线程执行完毕以后，再次执行该线程
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("t2");
        }) ;


        Thread t3 = new Thread(() -> {
            try {
                t2.join();                              // 加入线程t2,只有t2线程执行完毕以后，再次执行该线程
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("t3");
        }) ;

        // 启动线程
        t1.start();
        t2.start();
        t3.start();

    }

}
```

## 7.notify()和 notifyAll()有什么区别？
notifyAll：唤醒所有wait的线程

notify：只随机唤醒一个 wait 线程

## 8.wait 和 sleep 方法的不同？
1.sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法

2.sleep() 方法没有释放锁，而 wait() 方法释放了锁 。

3.wait() 方法被调用后，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。sleep()方法执行完成后，线程会自动苏醒。

## 9.如何停止一个正在运行的线程？
	1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止.(设置flag)

 	2.使用stop方法强行终止（不推荐，方法已作废）（t1.stop()）

 	3.使用interrupt方法中断线程

# 2.线程的并发安全
## 1.synchronized关键字的底层原理？<!-- 这是一张图片，ocr 内容为：MONITOR PUBLIC CLASS SYNCTEST STATIC FINAL OBJECT LOCK NEWOBJECT(); THREAD-2 STATIC INT COUNTER O; MONITOR被翻译为监视器,是由JVM提供,C++语言实现 PUBLIC STATIC VOID MAIN(STRING|ARGS){ SYNCNRONIZEA LOCK COUNTER+; WAITING MONITOR结构 J THREAD-5 THREAD-6 WAITSET BLOCKED THREAD-4 THREAD-3 THREAD-2 ENTRYLIST OWNER OWNER:存储当前获取锁的线程的,只能有一个线程可以获取 ENTRYLIST:关联没有抢到锁的线程,处于BLOCKED状态的线程 WAITSET:关联调用了WAIT方法的线程,处于WAITING状态的线程 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689217972195-73233122-6ac0-4aa0-9043-811224c5edc4.png)
1.Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】

2.它的底层由monitor实现的，monitor是C++实现的，线程获得锁需要使用对象关联monitor

3.在monitor内部有三个属性，分别是owner、entrylist、waitset

4.其中owner关联的是获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程

## 2.synchronized锁升级
Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。

1.重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。

2.轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性。

3.偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark  word中是否是自己的线程id即可，而不是开销相对较大的CAS命令。

## 2. JMM（Java 内存模型）
##  <!-- 这是一张图片，ocr 内容为：主内存 工作内存 共享变量 线程A JMM控制SAVA/LOAD 共享变量副本 共享变量 共享变量 工作内存 共享变量 JMM控制SAVA/LOAD 线程B 共享变量副本 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689218418715-cfb37445-73d6-48c2-ba3c-d2e0a589fcef.png)
1.定义了 Java 线程和内存之间的操作规范，解决多线程正确执行的问题。

2.把内存分为两块，一块是线程私有的工作内存，一块是线程公有的主内存。

3.线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存。

## 3.CAS
## <!-- 这是一张图片，ocr 内容为：一个当前内存值V,1日的预期盲A,即将更新的值B,当且仅当1目的预期借A和内存值V相同时,将内存值修改为日并 CAS数据交换流程 .这回TRUE,否则什么都不做,并这回FALSE.如果CAS操作失败,通过自施的方式等待并再次尝试,直到成功 主内存 工作内存 线程A 共享变量 V: INT A 100 JMM控制 共享变量副本 共享变量 A: INTA 100 A++ 共享变量 B:INTA101 共享变量 工作内存 共享变量 线程B JMM控制 共享变量副本 A INTA 100 B:INTA99 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689218689978-f4922287-3d24-499c-89d8-b17188e12600.png)
1.CAS的全称是：Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。

2.CAS使用到的地方很多：AQS框架。

3.在操作共享变量的时候使用的自旋锁，效率更高

4.CAS的底层调用的是由操作系统提供的Unsafe类中的方法，是其他语言实现（/ʌnˈseɪf/）

## 4.乐观锁和悲观锁的区别
1.CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。

2.synchronized，Lock是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会

-------------------------------------------------------------------------------------------------------------------

悲观锁：

1.悲观锁认为在并发情况下会发生冲突，因此在访问共享资源之前，会先加锁，保证在任意时刻只有一个线程能够访问该资源。

2.适用于写多读少的场景

乐观锁：

1.乐观锁认为在并发情况下不会发生冲突，因此在访问共享资源时不会加锁，而是先尝试执行操作，然后在更新资源时检查是否发生了冲突。如果没有发生冲突，操作成功；如果发生了冲突，需要重新尝试或者放弃操作。

      2.乐观锁适用于读多写少的场景

## 5. volatile
如果我们将变量声明为 volatile（/ˈvɒlətaɪl/） ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

1.保证线程间变量的可见性：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变

量的修改对另一个线程可见。

2.禁止指令重排序：指令重排：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，

阻止其他读写操作越过屏障，从而达到阻止重排序的效果

<!-- 这是一张图片，ocr 内容为：问题分析:主要是因为在VM虚拟机中有一个JT(即时编译器)给代码做了优化. WHILE (TRUE) WHILE(!STOP) 优化 !++; -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689219216858-ecaf4a6f-eea5-4c0e-81da-d8ff8737ebc1.png)

<!-- 这是一张图片，ocr 内容为：INT X; VOLATILE INT Y; X 1; @ACTOR 写操作加的屏障是阻止上方其它写操作越过屏障排 PUBLIC VOID ACTOR1() AAAAAAM 到VOLATILE变量写之下 X 1; Y  1; Y 1; 写读 &ACTOR R.R1 - Y; PUBLIC VOID ACTOR2(II_RESULT R) R.R1 -Y; AAWAN 读操作加的屏障是阻止下方其它读操作越过屏障排 R.R2 X; 到VOLATILE变量读之上 R.R2三X; -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689219236788-f497381d-18e7-47e7-bbdd-380eb2c997ff.png)

volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证

## 6.AQS
<!-- 这是一张图片，ocr 内容为：CAS设置STATE状态,保证操作的原子性 AQS是公平锁吗,还是非公平锁? 线程0 STATE 1有锁 0无锁 线程4 线程3 线程1 线程2 FIFO队列 线程4 个 TAIL HEAD 队列最后一个元素 队列中最久的一个元素 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689228748139-bb8ffbce-17cc-4664-bbe7-61304a1af22c.png)

1.是多线程中的队列同步器。是一种锁机制，它是作为一个基础框架使用的。

2.AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程。

3.在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0（无锁状态），如果队列中的有一个线程修改成功了state为1，则当前线程就相等于获取了资源。

4.在对state修改的时候使用的cas操作，保证多个线程修改的情况下原子性。 

| **<font style="color:rgb(51, 51, 51);">synchronized</font>** | **<font style="color:rgb(51, 51, 51);">AQS</font>** |
| :--- | :--- |
| <font style="color:rgb(51, 51, 51);">关键字，c++ 语言实现</font> | <font style="color:rgb(51, 51, 51);">java 语言实现</font> |
| <font style="color:rgb(51, 51, 51);">悲观锁，自动释放锁</font> | <font style="color:rgb(51, 51, 51);">悲观锁，手动开启和关闭</font> |
| <font style="color:rgb(51, 51, 51);">锁竞争激烈都是重量级锁，性能差</font> | <font style="color:rgb(51, 51, 51);">锁竞争激烈的情况下，提供了多种解决方案</font> |


AQS常见的实现类

1.ReentrantLock      阻塞式锁

2.Semaphore        信号量

3.CountDownLatch   倒计时锁

## 7.ReentrantLock的实现原理
<!-- 这是一张图片，ocr 内容为：NONFAIRSYNC NONFAIRSYNC继承自AQS STATE 1 NODE(THREAD-3) NODE(THREAD-1) NODE(THREAD-2) NODE(NULL) HEAD TAIL EXCLUSIVEOWNERTHREAD THREAD-0 线程来抢锁后使用CAS的方式修改STATE状态,修改状态成功为1,则让EXCLUSIVEOWNERTHREAD属性指向当前线理,获取敏成功 假如修改状态失败,则会进入双向队列中等待,HEAD指向双向队列头部,TAI指向双向队列尾部 当EXCLUSIVEOWNERTHREAD为NULL的时候,则会唤醒在双向队列中等待的线程 公平锁则体现在按照先后顺序获取锁,非公平体现在不在排队的线程也可以抢锁 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689229660874-ea6cb77a-79b5-4348-b1df-d2b3464c8f02.png)

1.ReentrantLock表示支持重新进入的锁，调用 lock 方法获取了锁之后，再次调用 lock，是不会再阻塞。

2.ReentrantLock主要利用CAS+AQS队列来实现。

3.支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁。

（英/ɪkˈskluːsɪv/）

## 8.synchronized和Lock有什么区别 ? 
1.synchronized 是关键字，用c++ 实现； Lock 是接口，用java 语言实现

2.使用 synchronized 时，退出同步代码块锁会自动释放，而Lock 需要手动调用 unlock 方法释放锁

3. Lock 有多种实现，如 ReentrantLock， ReentrantReadWriteLock

4.在低并发的情况下，synchronized 的性能高，在高并发的情况下，Lock 的性能高。

5.synchronized是非公平锁，lock可以是公平锁，也可以是非公平锁（默认）。

## 9.死锁
死锁：两个或多个线程相互等待对方释放所持有的资源而导致的无限循环等待的情况。

死锁产生的四个必要条件：

互斥条件，请求与保持条件，不可剥夺条件，循环等待条件

避免死锁:

避免死锁条件的出现

银行家算法

## 10. 如何进行死锁诊断？
使用jdk自带的工具：jps和 jstack

## 11.ConcurrentHashMap
（/ˈseɡmənt/）

<!-- 这是一张图片，ocr 内容为：7....Y,Y,.. SEGMENT[O] SEGMENT[1] HASHENTRY数组 SEGMENT数组 SEGMENT[2] SEGMENT[3] 可扩容 SEGMENT[4] HASHENTRY数组 SEGMENT[15] 可扩容 不可扩容 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689231176075-d3ab3939-0ec0-438f-b6a4-fd0553c0eea8.png)



<!-- 这是一张图片，ocr 内容为：N SEGMENT[O] MAP.PUT("NAME","ZHANGSAN"); CAS HASH(KEY) 尝试获 SEGMENT[1] 取锁 REENTRANTLOCK SEGMENT[2] SEGMENT[3] 通过HASH值定位 HASHENTRY数组下标 SEGMENT[4] SEGMENT[15] -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689231182318-4140da8e-e639-4ec1-8fec-e130105004fb.png)

<!-- 这是一张图片，ocr 内容为：在JDK1.8中,放弃了SEGMENT髓肿的设计,数据结构跟HASHMAP的数据结构是一样的:数组+红黑树+链表 采用CAS+SYNCHRONIZED来保证并发安全进行实现 CAS控制数组节点的添加 SYNCHRONIZED只锁定当前链表或红黑二叉树的首节点,只要HASH不冲突,就不会产生并发的问题,效率得到提升 7 2 3 63 CAS NULL NUL NULL 高级软件人 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689231217312-5542734d-be57-47cb-bbca-865b37727d58.png)

1. 底层数据结构：

JDK1.7底层采用分段的数组+链表实现

JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树

2. 加锁的方式

JDK1.7采用Segment分段锁，底层使用的是ReentrantLock

JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑二叉树的首节点，相对Segment分段锁粒度更细，性能更好

# 3.线程池
概念：线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务

好处：

1.降低资源消耗。

2.提高响应速度。

3.提高线程的可管理性。

## 1.线程池的核心参数
Executor(/ɪɡˈzekjətə(r)/)

<!-- 这是一张图片，ocr 内容为：PUBLIC THREADPOOLEXECUTOR(INT COREPOOLSIZE, INT MAXIMUMPOOLSIZE LONG KEEPALIVETIME TIMEUNIT UNIT, BLOCKINGQUEUE<RUNNABLE> WORKQUE, THREADF ACTORY THREADFAC TORY, REJECTEDEXECUTIONHANDLER HANDLER) -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689232038234-4bddf25a-96d2-4e17-86b9-425305f6b417.png)

corePoolSize 核心线程数目

maximumPoolSize 最大线程数 = (核心线程+救急线程的最大数目)

keepAliveTime 空闲线程存活时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放

unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等

workQueue 阻塞队列- 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务

threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等

handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略

<!-- 这是一张图片，ocr 内容为：线程池的执行原理知道嘛 提交任务 否 添加到工作线程并 核心线程是 否已满 执行 如果核心或临时线程执行完成任务后会检查阻塞队 否 添加任务到任务队 阻塞队列是 列中是否有需要执行的线程,如果有,则使用非核 列 否已满 心线程执行任务 是 是 线程数是否 否 创建非核心线程执 拒绝策略处理 小于最大线 行任务 程数 1.ABORTPOLICY:直接抛出异常,默认策略; 2.CALLERRUNSPOLICY:用调用者所在的线程来执行任务; 3.DISCARDOLDESTPOLICY:丢弃阻塞队列中靠最前的任务,并执行当前任务; 4.DISCARDPOLICY:直接丢弃任务; 小女人 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689232449957-5261fc3f-6976-4c2e-b9b8-a7dd9e3f122d.png)

## 2.线程池中有哪些常见的阻塞队列
workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务

1.<font style="color:#DF2A3F;">ArrayBlockingQueue</font>：基于数组结构的有界阻塞队列，FIFO。

2<font style="color:#DF2A3F;">.LinkedBlockingQueue</font>：基于链表结构的有界阻塞队列，FIFO。

3.DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的

4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。

<!-- 这是一张图片，ocr 内容为：ARRAYBLOCKINGQUEUE的LINKEDBLOCKINGQUEUE区别 LINKEDBLOCKINGQUEUE ARRAYBLOCKINGQUEUE 默认无界,支持有界 强制有界 底层是链表 底层是数组 是懒惰的,创建节点的时候添加数据 提前初始化NODE数组 入队会生成新NODE NODE需要是提前创建好的 两把锁(头尾) 一把锁 1 2 0 DATA DATA DATA NEXT NEXT NEXT LAST FIRST -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689233254372-a2599e98-35db-4f88-96c1-8bf82bbc10eb.png)

## 3.线程池的种类有哪些？
1.newFixedThreadPool：

（核心线程数与最大线程数一样，没有救急线程）（适用于任务量已知，相对耗时的任务）

创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待

2.newSingleThreadExecutor：

（核心线程数和最大线程数都是1）（适用于按照顺序执行的任务）

创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行

3.newCachedThreadPool：

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程

4.newScheduledThreadPool：

可以执行延迟任务的线程池，支持定时及周期性任务执行

（/ɪgˈzɛkjʊtəz/）

## 4.为什么不建议用Executors创建线程池（不推荐使用内置线程池）
<!-- 这是一张图片，ocr 内容为：THREADPOOLEXECUTOR 的方式,这 [强制]线程池不允许使用EXECUTORS去创建,而是通过T 样的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险. 说明:EXECUTORS 返回的线程池对象的弊端如下: 1) FIXEDTHREADPOOL 和 SINGLETHREADPOOL : 允许的请求队列长度为INTEGER.MAX VALUE,可能会堆积大量的请求,从而导致OOM. CACHEDTHREADPOOL : 2) 允许的创建线程数量为INTEGER.MAX VALUE,可能会创建大量的线程,从而导致OOM. -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689233982691-63d50723-be9d-4b4d-9100-fd8c9f586e92.png)

定长线程池的请求队列长度为Integer.MAX_VALUE（整型的最大值），可能会堆积大量的请求，从而导致OOM。

使用构造函数方式创建线程池可以明确线程池的运行规则，避免资源耗尽。

## 5.如何创建线程池？
1.通过ThreadPoolExecutor构造函数来创建（推荐）。

2.通过 Executor 框架的工具类 Executors 来创建。

# 4.其他
## 1.CountDownLatch
（/lætʃ/）（浪去）

CountDownLatch（闭锁/倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）

1.其中构造参数用来初始化等待计数值

2.await() 用来等待计数归零

3.countDown() 用来让计数减一

<!-- 这是一张图片，ocr 内容为：AWAIT( 等待,COUNT3 等待中 继续执行 COUNTDOWN( 继续执行 T2 COUNTDOWN( T3 COUNTDOWN0 T4 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689237797407-d568cb2d-048a-40ca-b163-3f6cf2402e84.png)

```java
public class CountDownLatchDemo {

    public static void main(String[] args) throws InterruptedException {
        //初始化了一个倒计时锁 参数为 3
        CountDownLatch latch = new CountDownLatch(3);

        new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+"-begin...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            //count--
            latch.countDown();
            System.out.println(Thread.currentThread().getName()+"-end..." +latch.getCount());
        }).start();
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+"-begin...");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            //count--
            latch.countDown();
            System.out.println(Thread.currentThread().getName()+"-end..." +latch.getCount());
        }).start();
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+"-begin...");
            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            //count--
            latch.countDown();
            System.out.println(Thread.currentThread().getName()+"-end..." +latch.getCount());
        }).start();
        String name = Thread.currentThread().getName();
        System.out.println(name + "-waiting...");
        //等待其他线程完成
        latch.await();
        System.out.println(name + "-wait end...");
    }
    
}
```

## 2.Semaphore
Semaphore [ˈsɛməˌfɔr] 信号量

当在多线程中提供了一个工具类Semaphore，信号量。在并发的情况下，可以控制方法的访问量

1. 创建Semaphore对象，可以给一个容量

2. acquire()可以请求一个信号量，这时候的信号量个数-1

3. release()释放一个信号量，此时信号量个数+1

```java
public class SemaphoreCase {
    public static void main(String[] args) {
        // 1. 创建 semaphore 对象
        Semaphore semaphore = new Semaphore(3);
        // 2. 10个线程同时运行
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {

                try {
                    // 3. 获取许可
                    semaphore.acquire();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                try {
                    System.out.println("running...");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("end...");
                } finally {
                    // 4. 释放许可
                    semaphore.release();
                }
            }).start();
        }
    }

}
```

## 3.ThreadLocal
概念：是 Java 中的一个类，为每个线程都分配一个独立的线程副本，在多线程环境下提供线程间的数据隔离，确保数据在不同线程之间是独立的。

2. ThreadLocal 同时实现了线程内的资源共享

3. 每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象

a)调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中

b)调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值

c)调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值

eg：

1.线程上下文传递：

在框架和中间件中将用户信息、请求ID存储到ThreadLocal中。在后续的请求处理链路中，都可以方便的去访问这些信息。

2.数据库的连接管理：

在多线程环境下，可以使用ThreadLocal来管理数据库连接，每个线程都可以拥有独立的数据库连接，避免多线程竞争数据库连接资源的问题。

3.事务管理：

在多线程环境下，可以使用ThreadLocal来管理事务，每个线程都可以拥有独立的事务，从而实现线程级别的事务隔离。

## 4. ThreadLocal内存泄漏问题
ThreadLocalMap 中的 key 是弱引用，值为强引用； key 会被GC 释放内存，关联 value 

的内存并不会释放。建议主动 remove 释放 key，value

# 0__________________________________________________________
## 3.volatile 实现原理
1.volatile 关键字在底层的实现主要是通过内存屏障（memory barrier）来实现的。内存屏障是一种 CPU 指令，用于强制执行 CPU 的内部缓存与主内存之间的数据同步。

2.在 Java 中，当线程读取一个 volatile 变量时，会从主内存中读取变量的最新值，并把它存储到线程的工作内存中。当线程写入一个 volatile 变量时，会把变量的值写入到线程的工作内存中，并强制将这个值刷新到主内存中。这样就保证了 volatile 变量的可见性和有序性。

## 4.保证线程安全的常用手段
1.使用锁机制：synchronized 关键字或 Lock 接口。

2.使用线程安全的容器：如 ConcurrentHashMap、Hashtable。需要注意的是，线程安全的容器底层通常也是使用锁机制实现的；

3.使用本地变量：线程本地变量是一种特殊的变量，它只能被同一个线程访问。在 Java 中，线程本地变量可以通过 ThreadLocal 类来实现。每个 ThreadLocal 对象都可以存储一个线程本地变量，而且每个线程都有自己的一份线程本地变量副本，因此不同的线程之间互不干扰。

# 0__________________________________________________________
## 1.同步和异步的区别
1.同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。

2.异步：调用在发出之后，不用等待返回结果，该调用直接返回。

## 2.synchronized 关键字的使用方式
1.修饰实例方法（锁当前对象实例）

2.修饰静态方法（锁当前类）

3.修饰代码块 （锁指定对象/类）

## 3.构造方法可以用 synchronized 修饰么？
先说结论：构造方法不能使用 synchronized 关键字修饰。

构造方法本身就属于线程安全的，不存在同步的构造方法一说

## 4.synchronized 和 volatile 有什么区别？
1. volatile性能肯定比synchronized要好，但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。

2.volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。

## 5.synchronized 和 ReentrantLock 有什么区别？
1.两者都是可重入锁

2.synchronized 是依赖于 JVM 实现的，ReentrantLock 是 JDK 层面实现的（需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）

3.ReentrantLock 比 synchronized 增加了一些高级功能（可实现公平锁 、可以绑定多个条件）

## 6.ReentrantReadWriteLock
由于 ReentrantReadWriteLock 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 ReentrantReadWriteLock 能够明显提升系统性能

## 7.ConcurrentHashMap 和 Hashtable 的区别
底层数据结构：：

1.JDK1.7 的 ConcurrentHashMap 底层采用分段的数组+链表 实现，JDK1.8 采用的数据结构是数组+链表/红黑二叉树。

2.Hashtable 采用数组+链表的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。

实现线程安全的方式（重要）：

1.JDK1.7 的时候，ConcurrentHashMap采用Segment分段锁，底层使用的是ReentrantLock

2.JDK1.8 的时候，ConcurrentHashMap数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。

3.Hashtable 使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态。



