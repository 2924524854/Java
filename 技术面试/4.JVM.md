# 1.JVM组成
## 1.JVM是什么
Java Virtual Machine Java程序的运行环境（java二进制字节码的运行环境）

好处：

1.一次编写，到处运行

2.自动内存管理，垃圾回收机制

## 2.JVM由哪些部分组成
<!-- 这是一张图片，ocr 内容为：JAVA代码转换为字节码 类加载子系统 JAVA CLASS JAVA SOURCE 把字节码加载到内存 运行数据区 JVM STACKS虚拟机栈 HEAP METHOD AREA/MATESPACE PC REGISTER 程序计数器 堆 方法区/元空间 NATIVE METHOD STACK 本地方法栈 字节码翻译为底层系统指令 C或C++实现 执行引擎 本地方法接口 本地库 JIT COMPILER GC INTERPRETER 即时编辑器 垃圾回收 解释器 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689248693566-1629cb9e-dca3-4e34-921e-77f4f8814c71.png)

主要组成部分:

- ClassLoader（类加载器）

- Runtime Data Area（运行时数据区，内存分区）

- Execution Engine（执行引擎）

- Native Method Library（本地库接口）

## 3.JVM的运行流程：
1.把 Java 代码转换成字节码文件。

2.类加载器把字节码文件加载到内存中

3.执行引擎将字节码翻译成底层系统指令交由 CPU 去执行；

4.调用本地库接口来实现整个程序的运行

## 4.组成部分：
组成部分：堆、方法区、栈、本地方法栈、程序计数器

1、堆内存是用来存储Java对象和数组。

2、方法区用于存储<font style="color:#DF2A3F;">已被虚拟机加载的信息，常量、静态变量</font>。

3、栈内存一般会用来存储局部变量和方法调用。

4、本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。

5、程序计数器（PC寄存器）中存放的是当前线程所执行的字节码的地址。

## 6.堆
线程共享的区域：主要用来保存对象实例，数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。

<!-- 这是一张图片，ocr 内容为：JAVA8-JVM内存结构 堆 虚拟机栈 本地方法栈 年轻代 程序计数器 EDEN S1 SO 本地内存 老年代 直接内存 元空间 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689249657564-f1ed055e-b1c8-4326-aa66-86a4628d5cdc.png)

- 年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到老年代区间。

- 老年代主要保存生命周期长的对象，一般是一些老的对象

- 元空间保存的类信息、静态变量、常量、编译后的代码



为了避免方法区出现OOM，所以在java8中将堆上的方法区【永久代】给移动到了本地内存上，重新开辟了一块空间，叫做<font style="color:#DF2A3F;">元空间</font>。那么现在就可以避免掉OOM的出现了。

<!-- 这是一张图片，ocr 内容为：JAVA8-JVM内存结构 JAVA7-JVM内存结构 堆 虚拟机栈 本地方法栈 虚拟机栈 本地方法栈 年轻代 年轻代 程序计数器 程序计数器 EDEN SO S1 S1 SO EDEN 本地内存 本地内存 老年代 老年代 避免 直接内存 直接内存 元空间 OOM 方法区/永久代 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689249569551-771adc03-d7f1-4341-8d99-3ee468b47c79.png)



	在 HotSpot JVM 中，永久代（ ≈ 方法区）中用于存放类和方法的元数据以及常量池，比如Class 和 Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。

## 7.栈
1.每个线程运行时所需要的内存，称为虚拟机栈，先进后出

2.每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存

3.每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

<!-- 这是一张图片，ocr 内容为：栈帧2 栈帧1(参数,局部 栈帧3 变量,返回地址) -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689249771034-ae0d698c-87ce-4a99-8a0f-711587061331.png)

1. 垃圾回收是否涉及栈内存？

   不涉及，垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放

2. 栈内存分配越大越好吗？

   未必，默认的栈内存通常为1024k

   栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为	        2048k，那么能活动的栈帧就会减半

3. 方法内的局部变量是否线程安全？

   1.如果方法内局部变量没有逃离方法的作用范围，它是线程安全的

   2.如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

4.栈内存溢出情况：

- 栈帧过多导致栈内存溢出，典型问题：递归调用

- 栈帧过大导致栈内存溢出

## 8.方法区
1.是各个线程共享的内存区域

2.主要存储类的信息、运行时常量池

3.虚拟机启动的时候创建，关闭虚拟机时释放

4.如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace

<!-- 这是一张图片，ocr 内容为：堆 本地内存 MATASPACE(元空间) 年轻代 CLASS SO S1 EDEN CLASSLOADER 老年代 运行常量池 永久代 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689250403897-2f1096ca-2ff1-4016-ae2d-d1a97c776b91.png)

常量池：可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型等信息

运行时常量池：常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

## 9.直接内存
不受 JVM 内存回收管理，是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高。

<!-- 这是一张图片，ocr 内容为：CPU 用户态(JAVA) 用户态(JAVA) 内核态(SYSTEM) 内存 JAVA堆内存 直接内存 系统内存 磁盘文件 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689250634356-b5b292ed-9738-4319-845d-8c3926a9da1e.png)

## 10.堆栈的区别是什么？
1、栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。

2、栈内存是线程私有的，而堆内存是线程共有的。

3,、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。

栈空间不足：java.lang.StackOverFlowError。

堆空间不足：java.lang.OutOfMemoryError。

# 2.类加载器
## 1.什么是类加载器，类加载器有哪些?
类加载器:

将字节码文件加载到内存中并转换为可执行的类。

类加载器种类:

类加载器根据各自加载范围的不同，划分为四种类加载器：

1.启动类加载器(BootStrap ClassLoader):

2.扩展类加载器(ExtClassLoader)：

3.应用类加载器(AppClassLoader)：

4.自定义类加载器：

上述三种类加载器的层次结构如下如下：

<!-- 这是一张图片，ocr 内容为：BOOTSTRAP CLASSLOADER 启动类加载器,由C++编写实现 LOAD FROM JAVA HOME/IRE/LIB EXTCLASSLOADER 扩展类加载器 LOAD FROM JAVA HOME/IRE/LIB/EXT 应用类加载器加载开发者自己编写 APPCLASSLOADER 的JAVA类 LOAD D FROM CLASSPATH 自定义类加载器,实现自定义类加 CUSTOMIZECLASSLOADER 载规则 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689251648752-3114dc2f-aa5a-483b-8563-4ad2f0c7375c.png)

## 2.双亲委派模型
如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。 

<!-- 这是一张图片，ocr 内容为：BOOTSTRAP CLASSLOADER LOAD FROM JAVA HOME/IRE/LIB EXTCLASSLOADER LOAD FROM JAVA HOME/IRE/LIB/EXT APPCLASSLOADER  LOAD FROM CLASSPATH CUSTOMIZECLASSLOADER -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689251733523-46be5a55-a792-4066-a84d-928a11bcdf03.png)

好处：

（1）通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。

（2）为了安全，保证类库API不会被修改

## 3.类加载的执行过程？
<!-- 这是一张图片，ocr 内容为：连接 准备 解析 加载 验证 卸载 初始化 使用 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689251892775-40eaa834-a78e-4a10-ad10-9a71cf1e910b.png)

1.1.加载：类加载器根据类的全限定名来查找对应的字节码文件

2.验证：验证加载的类是否符合 Java 虚拟机规范

3.准备：为类的静态变量分配内存，并设置默认初始值。

4.解析：将类中的符号引用转换为直接引用，比如将类中的方法名转换为实际的内存地址。

5.初始化：执行类的初始化代码，包括静态变量赋值和静态代码块的执行。

6.使用：类加载器将加载的类转换为JVM内部的类对象，可以使用这些类对象来创建实例、调用方法等操作。

7.卸载：在类不再被使用时，JVM会通过垃圾回收机制对无用的类进行卸载。

# 3.垃圾收回 
## 1.对象什么时候可以被垃圾器回收
如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。

## 2.如何判断对象是否存活
1.引用计数法

一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收。

2.可达性分析算法：

通过"GC Roots"的对象作为起始点，从这些节点开始向下搜索，当一个对象是与根对象没有有直接或间接的引用时，则可以当做垃圾回收。

## 3.什么对象可以作为GC Roots?
1.Java 虚拟机栈（栈帧中的本地变量表）中引用的对象；

2.方法区中类静态属性引用的对象；

3.方法区中常量引用的对象；

4.本地方法栈中 JNI（Native方法）引用的对象。

## 4.JVM 垃圾回收算法有哪些？
1.标记清除算法：垃圾回收分为2个阶段，分别是标记和清除,效率高,有磁盘碎片，内存不连续

2.标记整理算法：标记清除算法一样，将存活对象都向内存另一端移动，然后清理边界以外的垃圾，无碎片，对象需要移动，效率低

3.复制算法：将原有的内存空间一分为二，每次只用其中的一块,正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收;无碎片，内存使用率低

4.分代回收

<!-- 这是一张图片，ocr 内容为：GC ROOT GC ROOT GC ROOT GC ROOT 回收前 回收后 待回收的 空闲的空间 存活的对象 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689252931934-f83f280d-6640-461f-a1eb-24127267df81.png)

<!-- 这是一张图片，ocr 内容为：回收前 回收后 空闲的空间 待回收的 存活的对象 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689252949955-b7ca33e0-d26b-4748-9b15-fa5a15dc077f.png)

<!-- 这是一张图片，ocr 内容为：回收前 回收后 另一块内存 待回收的 空闲的空间 存活的对象 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689252958674-49440b52-fd0d-49ee-a216-db878c295852.png)

## 5.分代回收
<!-- 这是一张图片，ocr 内容为：EDEN FROM TO (8/10) (1/10) (1/10) YOUNG OLD 新生代(1/3堆空间) 老年代(2/3堆空间) -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689253485741-22e542c8-f368-4fd6-9717-08b272444c6d.png)

一、堆的区域划分

1. 堆被分为了两份：新生代和老年代【1：2】

2. 对于新生代，内部又被分为了三个区域。Eden区，幸存者区survivor(分成from和to)【8：1：1】

二、对象回收分代回收策略

1. 新创建的对象，都会先分配到eden区

2. 当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象

3. 将存活对象采用复制算法复制到to中，复制完毕后，伊甸园和 from 内存都得到释放

4. 经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将其复制到from区

5. 当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会提前晋升）

## 6.MinorGC、 Mixed GC 、 FullGC的区别是什么
- MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）

- Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有

- FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免？

## 7. JVM 有哪些垃圾回收器？
- 串行垃圾收集器（/ˈsɪəriəl/）

Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑

Serial 作用于新生代，采用复制算法

Serial Old 作用于老年代，采用标记-整理算法

垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。

<!-- 这是一张图片，ocr 内容为：安全点 阻塞 运行 运行 CPU 0 阻塞 运行 运行 CPU1 垃圾回收线程 运行 运行 CPU 2 运行 运行 阻塞 CPU 3 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689253795408-2d428240-d180-4eab-8a48-34ecaa15bab5.png)

- 并行垃圾收集器（/ˈpærəlel/）

Parallel New和Parallel Old是一个并行垃圾回收器，JDK8默认使用此垃圾回收器

Parallel New作用于新生代，采用复制算法

Parallel Old作用于老年代，采用标记-整理算法

垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。

<!-- 这是一张图片，ocr 内容为：安全点 运行 运行 垃圾回收线程 CPU 0 垃圾回收线程 运行 运行 CPU1 运行 垃圾回收线程 运行 CPU 2 运行 垃圾回收线程 运行 CPU 3 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689253812705-abf301bd-af7a-4013-96fc-f4c7956b5f24.png)

- CMS（并发）垃圾收集器

CMS是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。

<!-- 这是一张图片，ocr 内容为：安全点 安全点 安全点 安全点 运行 运行 阻塞 运行 重新标记 CPU 0 运行 并发清理 并发标记 初始标记 运行 重新标记 CPU 运行 阻塞 重新标记 运行 运行 CPU2 阻塞 运行 运行 运行 重新标记 CPU 3 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689254198540-ce0ca438-e0fc-49af-bab1-966913c19afa.png)

- G1垃圾收集器

-ZGC

1.ZGC采用复制算法。

2.ZGC是一种低延迟的垃圾回收器，主要针对大内存、多核心的应用场景，旨在减少垃圾回收带来的停顿时间。

## 8.G1垃圾收集器
1.应用于新生代和老年代，在JDK9之后默认使用G1

2.划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous（/hjuːˈmʌŋɡəs/）专为大对象准备

3.采用复制算法

4.响应时间与吞吐量兼顾

5.G1 收集器不会对所有老年代区域进行回收，而是优先选择回收价值高（存活对象少）的区域。

<!-- 这是一张图片，ocr 内容为：用户线程1 用户线程1 筛选回收 用户线程1 最终标记 CPU 0 筛选回收 最终标记 用户线程2 用户线程2 用户线程2 初始标记 CPU1 最终标记 用户线程3 筛选回收 用户线程3 并发标记 CPU 2 最终标记 用户线程4 用户线程4 用户线程4 筛选回收 CPU3 SAFEPOINT SAFEPOINT SAFEPOINT SAFEPOINT G1收集器运行示意图 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689814871101-92a1195b-97d3-4e5b-911a-1d51044320b2.png)

## 9.强引用、软引用、弱引用、虚引用的区别？
<!-- 这是一张图片，ocr 内容为：对象时,在垃圾回收后,内存仅 SER USER NEW USER(); USER USER USER NEW USER(); 论 SOFTREFERENCE SOFTREFERENCE - NEW SOFTREFERENCE(USER); I用 USER USER NEW USER(); WEAKREFERENCE WEAKREFERENCE - NEW WEAKREFERENCE(USER); USER USER NEW USER(); REFERENCEQUEUE REFERENCEQUEUE - NEW REFERENCEQUEUEUE(); PHANTOMREFERENCE(USER,QUEUE); PHANTOMREFERENCE PHANTOMREFERENCE - NEW NEW -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689255508435-1969d4de-4f85-4cea-a813-dc3528a8f5b3.png)

1.强引用：只要所有 GC Roots 能找到，就不会被回收

2.软引用：需要配合SoftReference使用，当垃圾多次回收，内存依然不够的时候会回收软引用对象

3.弱引用：需要配合WeakReference使用，只要进行了垃圾回收，就会把弱引用对象回收     ( 延伸话题：ThreadLocal内存泄漏问题  )

4.虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存

# 0____________________________________________________________
## 1.为什么要使用元空间替代永久代？
1.永久代的大小是固定的，当加载的类信息、常量池等数据超过了永久代的大小时，就会导致内存溢出。而元空间的大小可以根据需要进行调整。

2.元空间的数据可以存储在本地内存中，不再受到 Java 堆大小的限制，可以提高程序的灵活性和稳定性。

## 1.运行时数据区域
<!-- 这是一张图片，ocr 内容为：公众号:JAVAGUIDE 网站:JAVAGUIDE.CN 运行时数据区域(JDK1.7) 线程共享 方法区 (HEAP) (METHOD AREA) 字符串常量池 运行时常量池 (STRING CONSTANT POOL) (RUNTIME CONSTANT POOL) 线程私有 线程 线程 (THREAD) (THREAD) 虚拟机栈 虚拟机栈 (VM STACK) (VM STACK) 本地方法栈 本地方法栈 (NATIVE MATHOD STACK) (NATIVE MATHOD STACK) 程序计数器 程序计数器 (PROGRAM COUNTER REGISTER) (PROGRAM COUNTER REGISTER) 直接内存 (DIRECT MEMORY) 本地内存 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689248871255-6f68feef-7eef-4e6b-8aa9-5605701e4618.png)<!-- 这是一张图片，ocr 内容为：公众号:JAVAGUIDE 网站:JAVAGUIDE.CN 运行时数据区域(JDK1.8) 线程共享 (HEAP) 字符串常量池 (STRING CONSTANT POOL) 线程私有 线程 线程 (THREAD) (THREAD) 虚拟机栈 虚拟机栈 (VM STACK) (VM STACK) 本地方法栈 本地方法栈 (NATIVE MATHOD STACK) (NATIVE MATHOD STACK) 程序计数器 程序计数器 (PROGRAM COUNTER REGISTER) (PROGRAM COUNTER REGISTER) 本地内存 元空间 (METASPACE) 直接内存 (DIRECT MEMORY) 运行时常量池 (RUNTIME CONSTANT POOL) -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689248895919-de7b1c77-0cc9-4cc2-a9fa-e3162dafe59e.png)

线程私有的：

程序计数器

虚拟机栈

本地方法栈

线程共享的：

堆

方法区

直接内存 (非运行时数据区的一部分)

