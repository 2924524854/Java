MySQL5.7默认字符集latin1，MySQL8.0默认字符集为utf8mb4。utf8mb4是utf8的超集，支持所有Unicode字符。

# 1.索引
## 1.MYSQL支持的存储引擎有哪些, 有什么区别 ?
1.InnoDB：mysql5.5的引擎，支持事务、外键、表级锁和行级锁

2.MyISAM：是早期的引擎，它不支持事务、只有表级锁、也没有外键，用的不多

3.Memory：主要把数据存储在内存，支持表级锁，没有外键和事务。

## 2.索引的优缺点
优点：

1.使用索引可以加快数据的检索速度，提高查询效率。

2.通过创建唯一性索引，可以保证数据库表中数据的唯一性。

缺点：

1.创建索引和维护索引需要耗费时间。

2.对表中的数据进行修改时，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。

## 3.索引的底层数据结构
MySQL的InnoDB引擎采用的B+树的数据结构来存储索引

	1.磁盘读写代价B+树更低，非叶子节点只存储指针，叶子节点存储数据

 	2.B+树便于扫库和区间查询，叶子节点是一个双向链表

<!-- 这是一张图片，ocr 内容为：B-TREE,B树是一种多又路衡查找树,相对于二又树,B树每个节点可以有多个分支,即多叉. 以一颗最大度数(MAX-DEGREE)为5(5阶)的B-TREE为例,那这个B树每个节点最多存储4个KEY 数据 20 30 62 89 指针 88 25 78 23 58 34 56 64 15 18 86 28 92 96 10 11 12 17 20 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689318582580-40f04c08-e61e-4c3d-accc-91cf2766f254.png)

<!-- 这是一张图片，ocr 内容为：B+TREE是在BTREE基础上的一种优化,使其更适合实现外存储察引结构,INNODB存储引擎就是用B+TREE实现其察引结构 38 67 键值 数据 指针 29 55 58 16 94 90 34 29 38 45 12 98 94 55 9092 16 58 87 62 18 56 67 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689318595826-ef22e62d-cbf9-4e4b-b382-33dca6762b7a.png)

## 4.聚簇索引和非聚簇索引 
<!-- 这是一张图片，ocr 内容为：什么是聚簇索引和非聚簇索引? 30 15 ID 1 GENDER I NAME 男男 5 KIT 公男女女男男男男女男男 8 RUBY 27 25 60 10 聚集索引 MN ARM ROSE ZOOM TIM 28 45 26 30 72 25 90 60 80 DAWN PINE JACK ROBE LEE GEEK HERO 男男 LEM 容男女男男男女院 011 HILY JACK GEEK RUBY XINT ROXY 二级索引 OIL XINT MINA TACK KIT RUBY ZEELEM ARM DEWN ROSE ROXY XINTZOOM LIIYMINA GEEK HERO LEE LILY -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689319182606-dd1ecb58-0f56-4c32-bce9-a8a88b4de118.png)

<!-- 这是一张图片，ocr 内容为：回表查询 30 15 SELECT * FROM USER WHERE NAME : 'ARM'; 25 80 12 60 聚集索引 28 27 45 26 8 25 60 30 72 15 1011 21 90 80 ROW ROW ROW ROW ROW ROW ROW ROW ROW TOW ROW 回表查询 ROSE LEE 011 LILY JACK RUBY XINT GEEK 二级索引 ARM DAWN 011P1NE TIM LITYMINE XINTZOOM GEEK HERO 28 80 5 27 25 15 26 72 12 10 06 11 30 喜奶故性人才垃圾 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689319195269-1dadf400-d06f-4809-81e0-af1644227ab2.png)

聚簇索引：将数据存储与索引放到了一块，叶子节点保存了<font style="color:#DF2A3F;">行数据 </font>（必须有,而且只有一个）

非聚簇索引：将数据与索引分开存储，叶子节点关联的是<font style="color:#DF2A3F;">对应的主键 （</font>可以存在多个）

聚集索引选取规则：

 	1.如果存在主键，主键索引就是聚集索引。

 	2.如果不存在主键，将使用第一个唯一索引作为聚集索引。

 	3.如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个id作为隐藏的聚集索引。

回表查询：

通过非聚簇索引找到对应的主键值，到聚簇索引中查找整行数据，这个过程就是回表。

## 5.覆盖索引
覆盖索引：查询使用了索引，返回的列，必须在索引中全部能够找到

1.使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。

2.如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *

## 6.MYSQL超大分页怎么处理 ?
问题：在数据量比较大时，limit分页查询，需要对数据进行排序，效率低

解决方案：覆盖索引+子查询

## 7.索引创建原则
1.数据量较大，且查询比较频繁的表

2.常作为查询条件、排序、分组的字段

3. 尽量使用联合索引

4.内容较长，使用前缀索引

## 8.索引失效 
1.违反最左前缀法则

2.范围查询右边的列，不能使用索引

3.不要在索引列上进行运算操作， 索引将失效

4.字符串不加单引号，造成索引失效。(类型转换)

5.以%开头的Like模糊查询，索引失效

<!-- 这是一张图片，ocr 内容为：小米科技 北京市 AND AND ADDRESS EXPLAIN SELECT * FROM TB SELLER WHERE NAME STATUS MYSQL> FILTERED EXTRA POSSIBLE_KEYS ID KEY KEY_LEN TABLE SELECT_TYPE REF TYPE ROWS PARTITIONS 10.00 NULL USING TB_SELLER_INDEX 309 TB SE11 NULL SIMPLE INDEX CONDITION B_SELLER LLER NDEX RANGE -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689408289958-60c5db2d-df3c-4ef5-a742-5a69ace6cb20.png)

# 2.SQL的优化
## 1.定位慢查询
1.开源工具：Arthas（阿尔萨斯）

2.MySQL自带的慢查询日志，可以在MySQL的系统配置文件中开启这个慢日志的功能，并且也可以设置SQL执行超过多少时间来记录到一个日志文件中。

## 2.分析慢 SQL
可以采用EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息

<!-- 这是一张图片，ocr 内容为：RE ID 三 MYSQL> EXPLAIN SELECT * FROM T USER WHERE IC POSSIBLE_KEYS KEY KEY LEN FILTERED EXTRA ID TABLE SELECT_TYPE PARTITIONS REF TYPE TOWS NULL 98 NULL 1 100.00 PRIMARY PRIMARY SIMPLE USER CONST CONST (0.00  ROW IN SET, 1 WARNING SEC -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689410482506-d88900f9-7c77-47d8-8045-443ae56735e6.png)

#### <font style="color:rgb(240, 246, 252);background-color:rgb(13, 17, 23);">2.1主要返回字段说明</font>
| **<font style="color:rgb(240, 246, 252);">字段</font>** | **<font style="color:rgb(240, 246, 252);">说明</font>** |
| --- | --- |
| <font style="color:rgb(240, 246, 252);">id</font> | <font style="color:rgb(240, 246, 252);">查询中每个select子句的标识符，数字越大优先级越高</font> |
| <font style="color:rgb(240, 246, 252);">select_type</font> | <font style="color:rgb(240, 246, 252);">查询类型，例如SIMPLE(简单查询), PRIMARY, SUBQUERY等</font> |
| <font style="color:rgb(240, 246, 252);">table</font> | <font style="color:rgb(240, 246, 252);">查询的表名或别名</font> |
| <font style="color:rgb(240, 246, 252);">partitions</font> | <font style="color:rgb(240, 246, 252);">匹配的分区</font> |
| <font style="color:rgb(240, 246, 252);">输入</font> | <font style="color:rgb(240, 246, 252);">连接类型，反映了表的访问方式，性能由好到差：system > const > eq_ref > ref > range > index > ALL</font> |
| <font style="color:rgb(240, 246, 252);">possible_keys</font> | <font style="color:rgb(240, 246, 252);">可能用到的索引</font> |
| <font style="color:rgb(240, 246, 252);">key</font> | <font style="color:rgb(240, 246, 252);">实际使用的索引</font> |
| <font style="color:rgb(240, 246, 252);">key_len</font> | <font style="color:rgb(240, 246, 252);">使用索引的长度</font> |
| <font style="color:rgb(240, 246, 252);">ref</font> | <font style="color:rgb(240, 246, 252);">哪个字段与key一起使用查找数据</font> |
| <font style="color:rgb(240, 246, 252);">rows</font> | <font style="color:rgb(240, 246, 252);">扫描的行数，越小越好</font> |
| <font style="color:rgb(240, 246, 252);">filtered</font> | <font style="color:rgb(240, 246, 252);">经过表条件过滤后剩余的百分比</font> |
| <font style="color:rgb(240, 246, 252);">Extra</font> | <font style="color:rgb(240, 246, 252);">附加信息，如Using index、Using where、Using temporary、Using filesort等</font> |


## 3.sql的优化经验
1. 表的设计优化，数据类型的选择

2. 索引优化，索引创建原则

3. sql语句优化，避免索引失效，避免使用select *

4. 主从复制、读写分离，不让数据的写入，影响读操作

5. 分库分表

 表的设计优化：

① 设置合适的数值（tinyint int bigint），要根据实际情况选择

② 设置合适的字符串类型（char和varchar）char定长效率高，varchar可变长度，效率稍低

 SQL语句优化：

① SELECT语句务必指明字段名称（避免直接使用select * ）

② SQL语句要避免造成索引失效的写法

③ 尽量用union all代替union，因为union会多一次过滤，效率低（union关键字默认去重，如果使用union all可以包含重复项）

⑤ 能用inner join 就不用left join 、right join，如必须使用一定要以小表为驱动，内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边。left join 或 right join，不会重新调整顺序

 主从复制、读写分离：

如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构。

读写分离解决的是，数据库的写入，影响了查询的效率。

# 3.事物 
## 1.事务的特性是什么？
ACID：

1.原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。

2.一致性：事务完成时，必须使所有的数据都保持一致状态。

3.隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。

4.持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

## 2.并发问题
脏读：

一个事务对数据进行了修改，这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据。

不可重复读：

一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。

<!-- 这是一张图片，ocr 内容为：ID1(SELECT) 2 COMMIT ID1(UPDATE) 2 DB ID1(SELECT) 3 不可重复读 事务B 事务A -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690341807043-93dc08cc-4449-4531-96d2-1f7b173841da.png)

幻读：

幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

## 3.不可重复读和幻读有什么区别？
1.不可重复读的重点是内容修改或者记录减少，比如多次读取一条记录发现其中某些记录的值被修改；

2.幻读的重点在于记录新增，比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。

## 4.MySQL的隔离级别？
读未提交（READ-UNCOMMITTED）

特点：最低的隔离级别，事务中的修改，即使未提交，也可以被其他事务读取到。

优点：并发性能最好，读取到的数据最新。

缺点：脏读，即读取到未提交的数据，可能导致数据不一致性。

读已提交（READ-COMMITTED）

特点：保证事务读取到的数据都是已经提交的，其他事务提交的数据对该事务可见。

优点：避免了脏读的问题。

缺点：不可重复读，即同一个事务中，不同时间读取到的数据可能不一样。

可重复读（REPEATABLE-READ）

特点：保证同一个事务中，多次读取同一条记录时，读取到的数据都是一致的，MySQL 默认的事务隔离级别。

优点：避免了不可重复读的问题。

缺点：幻读，即在一个事务中，两次查询同一个范围的记录，但第二次查询却发现了新的记录。

串行化（SERIALIZABLE）

特点：最高的隔离级别，将所有的事务串行执行，保证了数据的完全隔离。

优点：避免了幻读的问题。

缺点：并发性能最差，可能导致大量的锁等待和死锁。

## 5.三大日志：
1.redo log（重做日志）：记录的是事务提交时数据页的物理修改，是用来实现<font style="color:#DF2A3F;">事务的持久性</font>。

MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫<font style="color:#DF2A3F;">数据页</font>，会放入到Buffer Pool<font style="color:#DF2A3F;">（缓冲池）</font>中。后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里。

<!-- 这是一张图片，ocr 内容为：INNODB存储引擎 3.记录更新信息 2.直接更新缓存数据 重做日志缓存 (REDO LOG BUFFER) 缓冲池 (BUFFER POOL) 4.清空REDO LOG BUFFE 1.磁盘加载数据放入到缓冲池 刷盘到REDO日志中 什么时候刷盘呢? 提交事务的时候吗? REDO.FILE 硬盘 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690354026613-a0767693-ca10-4b5d-8301-cb1d9fde3e8b.png)

该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。

<!-- 这是一张图片，ocr 内容为：BUFFER POOL REDOLOQ BUFFER UPDATE COMMIT UPDATE 内存结构 DELETE 数据页变化 - (WRITE-AHEAD LOGGING) WAL 磁盘结构 LE0/1 1B XXX.IBD 高级软件 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689338746917-1614aa5f-e7a6-4980-91f7-bee0cec085aa.png)

2.undo log （回滚日志）：用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚 和 MVCC(多版本并发控制) 。

undo log和redo log记录物理日志不一样，它是逻辑日志。

1.可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，

2.当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。

3.binlog：

binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”。

只要发生了表数据更新，都会产生 binlog 日志。MySQL数据库的数据备份、主备、主主、主从都需要依binlog来同步数据，保证数据一致性。

## 6.undo log和redo log的区别
1.redo log: 记录的是数据页的物理变化，服务宕机可用来同步数据

2.undo log ：记录的是逻辑日志，当事务回滚时，可以恢复原来的数据

3.redo log保证了事务的持久性，undo log保证了事务的原子性和一致性

## 7.MVCC 定义
MVCC 是多版本并发控制（Multi-Version Concurrency Control），在 MVCC 中，每个读操作会看到一个固定版本的数据库记录，即使在并发环境中，也不会出现读取到其他事务还未提交的数据。

MVCC 通过保存数据在某个时间点的快照来实现这一点。在读取数据时，只会读取在该时间点之前提交的数据。在写入数据时，会为每个写入操作创建一个新版本的数据，而不是直接覆盖原有的数据。这样，读操作就可以读取旧版本的数据，而写操作则可以写入新版本的数据，从而实现了并发控制。在 MySQL 中，InnoDB 存储引擎就是使用 MVCC 来实现并发控制的。

## 7.MVCC原理
redo log保证了事务的持久性，undo log保证了事务的原子性和一致性，排他锁和MVCC保证事务中的隔离性。

主要依赖于数据库记录中的隐藏字段、undo log日志、readView。

1.隐藏字段是指：

DB_TRX_ID（6字节）：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。

DB_ROLL_PTR（7字节）回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。

DB_ROW_ID（6字节）：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。

2.undo log主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表

<!-- 这是一张图片，ocr 内容为：UNDO LOG版本链 事务4 事务3 事务5 事务2 ID DB TRX ID DB ROLL PTR 开始事务 开始事务 开始事务 开始事务 NAME AGE 记录 修改ID为30记录.AGE改为3 查询ID为30的记录 30 A3 0X00003 10 提交事务 ,修改ID为30记录,NAME改为A3 查询ID为30的记录 提交事务 0X00003 3 30 0X00002 A3 修改ID为30记录,AGE改为10 UNDO LOGI 查询ID为30的记录 查询ID为30的记录 2 0X00001 A30 0X00002 30 提交事务 30 30 A30 OX00001 NULL -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689422843228-32ca5be7-ce1a-46eb-8c1e-64a002e0bc1d.png)

3.readView解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据。

1.当前读：

读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select ... lock in share mode(共享锁)，select ... for update、update、insert、delete(排他锁)都是一种当前读。

2.快照读：

简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。

Read Committed：每次select，都生成一个快照读。

Repeatable Read：开启事务后第一个select语句才是快照读的地方。

## 8.MVCC和间隙锁
MVCC 中没有用到锁，它是通过多版本并发控制的手段来实现数据库并发访问的，这样相比于加锁性能就会好很多。

## 9.MVCC 可以解决幻读吗？
MVCC 只能解决读取数据时的幻读问题，对于写入数据时的幻读问题，还需要配合锁机制或使用更高的事务隔离级别（串行化）来解决。

## 10.读写分离
读写分离：将对数据库的读写操作分散到不同的数据库节点上。 这样能够小幅提升写性能，大幅提升读性能。

实现：

1.部署多台数据库，选择其中的一台作为主数据库负责写数据，其他作为从数据库负责读数据。

2.保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的主从复制。

## 11.主从复制
MySQL主从复制的核心就是二进制日志（binlog），记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。

步骤：

1.主库在事务提交时，会把数据变更记录在二进制日志文件 binlog 中。

2.从库读取主库的 binlog二进制日志文件 ，写入到从库的relay Log中继日志文件。

3.从库的 SQL 线程读取 relay log 同步数据本地。

<!-- 这是一张图片，ocr 内容为：MASTER SLAVE INSERT IOTHREAD INSERT SOLTHREAD READ READ DATA WRITE REPLAY CHANGE BINLOG RELAY LOG -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689341036010-6e8b5d87-d8c3-4189-97b0-2df3a91c923f.png)

## 12.分库分表
<!-- 这是一张图片，ocr 内容为：DB MASTER DB WRITE 数据库 同步 应用 DB 中间件 DB READ SLAVE DB DB 分担了访问压力 解决存储压力 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689341148066-403bfee3-9a5a-4c1e-ab5d-786b93a637ef.png)

1.分库 ：就是将数据库中的数据分散到不同的数据库上。

垂直分库：就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。（将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库）

<!-- 这是一张图片，ocr 内容为：用户库 商品库 订单库 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689342286017-a3d77cb9-5771-4dd7-914e-d03c064d6a35.png)

水平分库 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。（订单表数据量太大，你对订单表进行了水平切分（水平分表），然后将切分后的 2 张订单表分别放在两个不同的数据库。）

<!-- 这是一张图片，ocr 内容为：订单表 ID MEMBER_ID 0 2999999 5999999 公众号:JAVAGUIDE 网站:JAVAGUIDE.CN 订单表1 订单表2 ID ID MEMBER-ID MEMBER_ID 0 3000000 5999999 2999999 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689342297849-46c6421b-4a69-400a-8544-12eb4eb0ccbe.png)

2.分表 ：就是对单表的数据进行拆分。、

垂直分表 是对数据表列的拆分，把一张列比较多的表拆分为多张表。

水平分表 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。

<!-- 这是一张图片，ocr 内容为：垂直拆分 MEMBER_ID TOTAL_AMOUNTL ID STATUS REC_PHONE REC_NAME 0 水平拆分 2999999 5999999 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689342349676-f05d701b-8eb4-49d3-949e-932b13fe692a.png)

## 13.什么情况下需要分库分表？
数据读写速度越来越慢，占用的空间越来越大，备份时间越来越长。

# 0—————————————————————————
## 1.关系型数据库和非关系型数据库？
1.关系型数据库采用表格形式存储数据，每个表格包含多个行和列，每一行代表一条记录，每一列代表一种属性。非关系型数据库没有固定的模式，通常采用文档、键值对、图形等方式存储数据。

2.关系型数据库使用SQL语句进行查询，且支持分组、排序等操作，非关系型数据库使用特定的API 进行查询。

3.关系型数据库将数据存储在硬盘中，查询速度较慢；非关系型数据库将数据存储于缓存之中，查询速度快。

4.关系型数据库支持事务处理可以保证数据的完整性和一致性，非关系型数据库对于事务的操作不能很好的支持。



## 2.行锁和表锁
行锁：对表中的某一行数据进行锁定，当有事务修改该行数据时，其他事务无法同时修改该行数据，从而保证数据的一致性。（行锁的粒度最细，对并发性能的影响最小）

表锁：对整张表进行锁定，当有事务对表中任意一行数据进行修改时，其他事务无法修改整张表中的任意一行数据，从而保证数据的一致性。（表锁的粒度最大，对并发性能的影响最大）

## 3.InnoDB 有哪几类行锁？
InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：

记录锁（Record Lock）：也被称为记录锁，属于单个行记录上的锁。

间隙锁（Gap Lock）：锁定一个范围，不包括记录本身。

临键锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。

记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。

## 4.共享锁和排他锁
不不论是表级锁还是行级锁，都存在共享锁（Share Lock）和排他锁（Exclusive Lock）这两类：

共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。

排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁。

由于 MVCC 的存在，对于一般的 SELECT 语句，InnoDB 不会加任何锁。不过可以通过语句显式加共享锁或排他锁。

```java
# 共享锁
SELECT ... LOCK IN SHARE MODE;
# 排他锁
SELECT ... FOR UPDATE;
```





