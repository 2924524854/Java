## 1.缓存穿透
大量的请求查询不存在于缓存和数据库中的数据，导致这些请求直接访问数据库，占用数据库资源。

原因：

1.恶意请求（异常情况）

2.高并发请求（正常业务）

策略：

1.缓存空数据

2.布隆过滤器

布隆过滤器：可以用于快速判断一个元素是否存在于集合中。在缓存中引入布隆过滤器，可以在查询请求到达时，首先通过布隆过滤器判断该请求对应的数据是否存在于缓存或数据库中，从而避免无效的查询操作。

<!-- 这是一张图片，ocr 内容为：缓存预热时,预热布隆过滤器 查询布隆过滤器 REDIS查不到,查DB 布隆过滤中存在,查REDIS 布隆过滤器 DB 根据ID查询文章 不存在,直接返回 命中,返回结果 DB查询到结果,返回(返回之前数据存储到REDIS) -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690380158664-4de1cd1f-b231-423c-a1f0-a0e809e8bd54.png)

<!-- 这是一张图片，ocr 内容为：BITMAP(位图):相当于是一个以(BIT)位为单位的数组中每个单元只能存储二进制数或1 布隆过滤器作用:布隆过滤器可以用于检索一个元素是否在一个集合中. )存储数据:ID为1的数据,通过多个HASH函数获取HASH值,根据HASH计算数组对应位置改为1 ID1 查询数据:使用相同HASH函数获取HASH值,判断对应位置是否都为1 HASH2(1)3 HASH3(1)-7 HASH1(1)1 0 0 0 0 0 0 0 0 0 3 8 4 15 14 10 13 11 12 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689426575628-e8888d9b-b922-43b6-8279-7abc17545cb0.png)

布隆过滤器实现方案：Redisson

## 2.缓存击穿
某个热点数据过期或失效时，同时有大量的请求访问该数据，导致请求直接访问数据库，给数据库造成压力。

原因：

1.热点数据失效

2.并发访问热点数据

策略：

1.设置热点数据永不过期或者过期时间比较长

2.加互斥锁或分布式锁

3.限制热点数据的并发访问

## 3.缓存雪崩
缓存中大量数据同时过期或失效，导致请求直接访问数据库，给数据库造成压力。

策略：

1.设置随机过期时间，避免大量数据同时过期。

2.实现缓存预热：缓存预热会在缓存过期之前，以一定的时间间隔加载数据到缓存中。这样，缓存中的数据可以保持相对均匀的分布，避免了大量缓存同时过期并导致数据源压力剧增的情况。

3.设置熔断机制

## 4.redis与mysql数据同步（双写一致）
<!-- 这是一张图片，ocr 内容为：双写一致 双写一致性:当修改了数据库的数据也要同时更新缓存的数据,缓存和数据库的数据要保持一致 查REDIS REDIS查不到,查DB 请求数据 DB 命中,返回结果 DB查询到结果,返回(返回之前数据存储到REDIS) 有脏数 据风险 读操作:缓存命中,直接返回;缓存未命中查询数据库,写入缓存,设定超时时间 写操作:延迟双删 延时 删除缓存 修改数据库 删除缓存 代码耦 合性高 1.先删除缓存,还是先修改数据库 DB DB 2.为什么要删除两次缓存? 3.为什么要延迟删除? 主 从 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1694050853660-caebd9db-4555-4b18-a6dd-5ce10977cbe9.png)

1. 强一致性的：

采用redisson的读写锁。

在读数据的时候添加共享锁，更新数据的时候添加排他锁，保证在写数据的同时不让其他线程读数据，避免产生脏数据。

2.允许延迟一致：

采用异步通知。

使用MQ中间件，更新数据之后，通知缓存删除。

利用canal中间件，伪装为mysql的一个从节点，canal通过读取binlog日志更新缓存。

## 5.持久化
1.快照方式（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘。

2.文件追加方式（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中。

3.混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。

## 6.RDB和AOF的区别：
1.1.写入方式：RDB 是通过快照机制，将 Redis 中的数据集以二进制文件的方式写入硬盘；AOF 则是通过将 Redis 服务器执行的所有写命令（set、del）记录在 AOF 文件中，写入方式是追加写入。

2.数据恢复：当 Redis 重启时，可以根据 RDB 文件或 AOF 文件来恢复数据。恢复 RDB 文件比恢复 AOF 文件快，因为 RDB 文件包含了一个时间点上的快照，可以直接将整个数据集加载到内存中。而恢复 AOF 文件则需要逐条执行文件中记录的命令，需要更长的时间。

3.数据完整性：RDB 文件保存的是 Redis 在某个时间点的数据快照，如果 Redis 在快照操作之后宕机，可能会丢失最后一次快照后的数据。而 AOF 文件记录了 Redis 所有的写命令，因此即使 Redis 宕机，也可以根据 AOF 文件恢复数据。

4.文件大小：RDB 文件通常比 AOF 文件小，因为它只保存了一个时间点的数据快照，而 AOF 文件保存了所有的写命令。

## 7.数据过期策略
1.惰性删除：在key过期后，不去管它，当需要该key时，我们再检查其是否过期，如果过期，我们就删掉它，反之返回该key。

2.定期删除：每隔一段时间，我们就对一些key进行检查，删除里面过期的key，有slow和fast两种模式，可以通过修改配置文件redis.conf 的 hz 选项来调整这个次数

Redis的过期删除策略：惰性删除 + 定期删除两种策略进行配合使用。

## 8.数据淘汰策略
redis中提供了很多种数据淘汰策略，默认是noeviction，不删除任何数据，内部不足直接报错。（/ɪˈvɪkʃn/驱逐）

LRU（Least Recently Used）最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。

LFU（Least Frequently Used）最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。

我们在项目设置的allkeys-lru，挑选最近最少使用的数据淘汰，把一些经常访问的key留在redis中

## 9.Redis分布式锁如何实现 ? 
使用redisson实现的分布式锁，底层是setnx和lua脚本（保证原子性）

在redis中提供了一个命令setnx(SET if not exists)，由于redis的单线程的，用了命令之后，只能有一个客户端对某一个key设置值，在没有过期或删除key的时候是其他客户端是不能设置这个key的。

<!-- 这是一张图片，ocr 内容为：获取锁: #添加锁,NX是互斥,EX是设置超时时间 SET LOCK VALUE NX EX 10 释放锁: 释放锁,删除即可 DEL KEY -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689491847612-6c3ac362-98d8-40d8-82eb-70fa03359ff7.png)

## 10.Redisson是如何控制锁的有效时长?
<!-- 这是一张图片，ocr 内容为：每隔(RELEASETIME/3)的时间做一次续期 加锁成功 WATCH DOG 看门狗 操作REDIS 加锁 释放锁 加锁,设置过期时间等操作都是基于LUA脚本完成 是否加锁成功 加锁 KITAN WHILE循环,不断尝试获取锁 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690420688940-20eda864-f89b-462f-b4de-67b1c3c02c41.png)

在redisson的分布式锁中，提供了一个WatchDog(看门狗），一个线程获取锁成功以后，WatchDog会给持有锁的线程续期（默认是每隔10秒续期一次）。

好处：

在高并发下，一个业务有可能会执行很快，先客户1持有锁的时候，客户2来了以后并不会马上拒绝，它会自旋不断尝试获取锁，如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升。

## 11.redisson实现的分布式锁是可重入的吗？
可以重入，多个锁重入需要判断是否是当前线程，在redis中进行存储的时候使用的hash结构，来存储线程信息和重入的次数。

<!-- 这是一张图片，ocr 内容为：PUBLIC VOID ADD1() 利用HASH结构记录线程ID和重入次数 RLOCK LOCK - REDISSONCLIENT.GETLOCK("HEIMALOCK"); BOOLEAN ISLOCK - LOCK.TRYLOCK(); VALUE 11执行业务 KEY ADD2(); FIELD VALUE 11释放锁 R HEIMALOCK THREAD1 LOCK.UNLOCK(); PUBLIC VOID ADD2() RLOCK LOCK - REDISSONCLIENT.GETLOCK("HEIMALOCK"); BOOLEAN ISLOCK - LOCK.TRYLOCK(); |执行业务 11释放锁 LOCK.UNLOCK(); -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689493485693-6474c9ad-e718-46ad-ac10-38c593cf4d1f.png)

## 12.Redisson锁能解决主从数据一致的问题吗？
不能解决，但是可以使用redisson提供的红锁来解决，但是这样的话，性能就太低了。

## 13.Redis集群有哪些方案？
 	1.主从复制（高可用）

 2.哨兵模式（高并发读）

 3.分片集群（海量数据存储问题、高并发写的问题）

## 14.主从复制
单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。

全量同步：

1.从节点请求主节点同步数据（replication id、 offset）

2.主节点判断是否是第一次请求，是第一次就与从节点同步版本信息（replication id和offset）

3.主节点执行bgsave，生成RDB文件后，发送给从节点去执行

4.在rdb生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件）

5.把生成之后的命令日志文件发送给从节点进行同步

<!-- 这是一张图片，ocr 内容为：REPLICATIONID:简称REPLID,是数据集的标记,ID一致则说明是同一数据集.每一个MASTER都有唯一的REPIID. 主从数据同步原理 SLAVE则会继承MASTER节点的REPLID OFFSET:偏移量,随着记录在REPLBAKLOG中的数据增多而逐渐增大,SLAVE完成同步时也会记录当前同步的 主从全量同步: 如果SLAVE的OFFSET小于MASTER的OFFSET,说明SLAVE数据落后于MASTER,需要更新. MASTER SLAVE 2.请求数据同步 OFFSET REPLID 1.执行REPLICAOF命令 建立连接 3.判断是否是第一次同步REPLID是否一致 4.是第一次,返回MASTER的数据版本信息REPLID,OFFSET 5.保存 版本信息 6.执行BGSAVE,生成RDB 7.发送RDB文件 9.记录RDB期 间的所有命令 8.清空本地数据, REPL 加载RDB文件 BAKLOG 10.发送REPL_BAKLOG中的命令 11.执行 接收到 的命令 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689494606279-9e4fcff2-e5b2-421a-b09f-24a1879ffca2.png)

增量同步：

1.从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值

2.主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步

<!-- 这是一张图片，ocr 内容为：MASTER SLAVE 1.重启 2.PSYNC REPLID OFFSET 3.判断请求REPLID是否一致 4.暴笼第决次返回复节南REPLIEDOFFSET 6.保存 版本信息 6.去REPL_BAKLOG中获取 OFFSET后的数据 REPL 7.发送OFFSET后的命令 BAKLOG 8.执行命 令 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689494638152-edcb7408-a39e-4796-8692-5f892a554d58.png)

## 15.哨兵模式
<!-- 这是一张图片，ocr 内容为：LLLLLLLLLLLLLLLLLL SENTINEL SENTINEL SENTINEL 主观下线 AN 主观下线 越高 LLLLLLLALLLLLLL SLAVE MASTER SLAVE 数据 数据 同步 同步 LTHTTINGTHTTHTHTHTILTHT -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689496529887-68a567c2-9fba-45b0-824e-e91f78b30395.png)

监控和管理分布式系统中多个组件（/ˈsentɪnl/）

1.监控：Sentinel 会不断检查您的master和slave是否按预期工作。

2.自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。

3.通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端。



哨兵模式基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令

• 主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。

• 客观下线：若超过指定数量的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。

## 16.redis集群脑裂
<!-- 这是一张图片，ocr 内容为：- SENTINEL SENTINEL SENTINEL 监控集群状态 服务状态 变更通知 MASTER 继续写 数据 REDISCLIENT MASTER 同步 SLAVE -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689496601406-4a7d4194-d700-4931-8df2-fe1e208f4ae8.png)

集群脑裂是由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将老的主节点降为从节点，这时再从master同步数据，就会导致数据丢失

解决：

1.可以设置最少的从节点数量。

2.缩短主从数据同步的延迟时间，达不到要求就拒绝请求。

## 17.分片集群
<!-- 这是一张图片，ocr 内容为：SLAVE SLAVE 数据同步 IIIIIILLIL MASTER 心跳 心跳 心跳 MASTER MASTER 数据同步 数据同步 SLAVE SLAVE SLAVE SLAVE -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689496916212-829405b0-33bd-4a7f-848d-e9575ba54413.png)

1.集群中有多个master，每个master保存不同数据

2.每个master都可以有多个slave节点

3.master之间通过心跳监测彼此健康状态

4.客户端请求可以访问集群任意节点，最终都会被转发到正确节点

## 18.分片集群中数据是怎么存储和读取的？
<!-- 这是一张图片，ocr 内容为：SET NAME ITHEIMA SET 1 MASTER 0-5460 CRC16计算NAME的HASH值 888888 CRC16算法计算AAA的HASH值 999999元 MASTER 5461-10922 666666%1638411306 888888%16384152 MASTER 10923-16383 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690427649086-650be78a-8d9b-4b15-9de2-5682a789b944.png)

Redis 集群引入了哈希槽的概念，集群中每个主节点绑定了一定范围的哈希槽， key通过计算hash值后对 16384 取模来决定放置哪个槽，通过槽找到对应的节点进行存储。

## 19.Redis是单线程的为什么还那么快？
1.Redis是纯内存操作，执行速度非常快。

2 采用单线程，避免不必要的上下文切换，多线程还要考虑线程安全问题

3. 提供了多种高效的数据结构，如哈希表、有序集合等，能够快速地进行插入、删除等操作。

4.使用异步 I/O 技术，可以在等待客户端输入输出时继续处理其他请求，从而提高了系统的吞吐量。

5.提供了多种持久化机制，如 RDB、AOF 可以在不影响性能的情况下保证数据的安全。

## 0————————————————————————————
## 1.Redis有哪些数据类型？
String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2022/png/34358440/1670035300656-12e6fb21-8887-41d0-9dcb-bdc135e7a024.png?x-oss-process=image%2Fresize%2Cw_1575%2Climit_0)

## 2.有序集合底层是如何实现的？
有序集合类型相比于集合类型多了一个排序属性 score（分值），有序集合的存储元素值是不能重复的，但分值是可以重复的。

<!-- 这是一张图片，ocr 内容为：SCORE:10 VALUE1 ZSET SCORE10 VALUE2 SCORE:20 VALUE3 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689498136812-d4e4e59c-68f7-4c80-ad86-e8d3970abd71.png)

有序集合是由 ziplist (压缩列表) 或 skiplist (跳跃表) 组成的。

1.压缩列表 ziplist 本质上就是一个字节数组，是 Redis 为了节约内存而设计的一种线性数据结构，可以包含多个元素，每个元素可以是一个字节数组或一个整数。

2.跳跃表 skiplist 是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

当数据比较少时，有序集合是压缩列表 ziplist 存储的，反之则为跳跃表 skiplist 存储。

## 3.Redis如何实现消息队列？
Redis 的 List 数据结构可以实现消息队列的入队和出队操作。生产者将消息插入到 List 的尾部，消费者从 List 的头部获取消息，实现先进先出的消息处理。



