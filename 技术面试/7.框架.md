## 1.单例Bean是线程安全的吗？
非线程安全的，无状态的单例 Bean 是线程安全的，而有状态的单例 Bean 是非线程安全的。

**有状态和无状态：**

有状态的 Bean 是指 Bean 中包含了状态，比如成员变量，而无状态的 Bean 是指 Bean 中不包含状态，比如没有成员变量，或者成员变量都是 final 的。

**为什么非线程安全：**

Spring 默认的 Bean 是单例模式，意味着容器中只有一个 Bean 实例，所有的线程都会使用这个唯一的 Bean 实例，如果多个线程同时修改这个单例 Bean，就会产生线程安全问题。

**如何保证线程安全：**

1.在Bean上添加注解将其变为多例 Bean。这样每次注入时返回一个新的实例，避免竞争。

2.在Bean中对需要同步的方法或代码块添加Synchronized锁或使用Java中的线程同步工具ReentrantLock等。

3.使用线程安全的集合。

<!-- 这是一张图片，ocr 内容为：DCONTROLLER @REQUESTMAPPING("/USER") PUBLIC CLASS USERCONTROLLER 成员方法需考虑线程安全 PRIVATE INT COUNT -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689505904002-dd5da590-fe86-4cb8-a257-53461244a253.png)

## 2.什么是AOP          
面向切面编程，将横切关注点从核心业务逻辑中分离出来。横切关注点是那些存在于多个模块中，但又不属于核心业务逻辑的功能，例如日志记录、事务管理等。

常见的AOP使用场景：

1.记录操作日志

2.缓存处理

3.Spring中内置的事务处理

## 3.Spring中的事务是如何实现的
1.编程式事务控制：需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用

2.声明式事务管理：通过AOP对方法前后进行拦截，在执行方法之前开启事务，在执行方法之后提交或者回滚事务。将事务处理的功能编织到拦截的方法中。

## 4.Spring中事务失效的场景有哪些
1.异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出

2.非运行时异常：默认情况下，Spring只会对非运行时异常及其子类进行回滚，其他类型的异常不会触发事务回滚

3.非public方法导致的事务失效，改为public

## 5.Spring中bean的生命周期
<!-- 这是一张图片，ocr 内容为：构造函数 BEANDEFINITION BEAN的创建和初始化赋值是分开的 依赖注入 AWARE接口 BEANNAMEAWARE APPLICATIONCONTEXTAWARE BEANFACTORYAWARE BEANPOSTPROCESSOR#BEFORE 自定义INIT方法 初始化方法 INITIALIZINGBEAN JDK动态代理 动态代理 BEANPOSTPROCESSOR#AFTER AOP CGLIB动态代理 销毁BEAN -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689507656830-c4abce92-1174-4721-a817-01191d271c4d.png)

1.实例化（Instantiation）：在 Spring 容器启动时，会根据配置文件或注解等方式创建 Bean 的实例。

2.属性赋值（Property Injection）：Spring会将配置的属性值或引用注入到Bean中。

3.初始化（Initialization）：在属性注入完成后，Spring 容器会调用 Bean 的初始化方法进行初始化。

4.使用（In Use）：Bean实例被容器管理后，可以通过容器获取Bean实例并使用。

5.销毁（Destruction）：在应用程序关闭时，Spring 容器会自动销毁所有的 Bean 实例。

## 6.Spring中的循环引用
在依赖注入的过程中，两个或多个Bean之间相互依赖，形成了一个循环依赖关系。（A依赖于B,B依赖于A）

1.三级缓存：Spring容器会将Bean的创建状态暂存到三级缓存中。

2.使用@Lazy进行懒加载：在容器启动时不创建Bean实例，而在第一次使用时才进行初始化。

<!-- 这是一张图片，ocr 内容为：PUBLICA(@LAZYBB) SYSTEM.OUT.PRINTLN("A的构造方法执行了..."); THIS.B B ; -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689508061960-2f65fb8e-c11d-4e20-86e7-e6875d255062.png)

## 7.SpringMVC的执行流程
<!-- 这是一张图片，ocr 内容为：{KEY:/USER/GETBYLD/1,VALUE:"类名#方法名"... HTTP://LOCALHOST:8080/USER/GETBYLD/1 2.查询HANDLER 1.请求 前端控制器 处理器映射器 6.响应 HANDLERMAPPING DISPATCHERSERVLET 3.返回处理器执行链 HANDLEREXECUTIONCHAIN 4.请求执行HANDLER 方法上添加了@RESPONSEBODY 通过HTTPMESSAGECONVERTER来返回结果转换为JSON并响应 5.请求 处理器适配器 处理参数 处理器HANDLER HANDLERADAPTOR 处理返回值 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689508428623-f096c784-7ce2-4a9e-972f-1465b7ab403f.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2022/png/34358440/1669034336997-f556769e-7a42-4635-ad74-b96fb6aa8c46.png?x-oss-process=image%2Fresize%2Cw_929%2Climit_0)

① 用户发送请求到前端控制器

②前端控制器收到请求调用处理器映射器，处理器映射器找到具体的处理器，返回给前端控制器。

④ 前端控制器调用处理器适配器，处理器适配器经过适配调用具体的处理器（Handler/Controller）

⑥处理器执行完成返回ModelAndView对象，处理器适配器将执行结果ModelAndView返回给前端控制器

⑧ 前端控制器将ModelAndView传给视图解析器，视图解析器解析后返回具体View（视图）

⑩ 前端控制器根据View进行渲染视图，然后把渲染后的视图响应返回给客户端

## 8.SpringBoot自动装配原理
<!-- 这是一张图片，ocr 内容为：@SPRINGBOOTCONFIGURATION @ENABLEAUTOCONFIGURATION @TARGET({ELEMENTTYPE.TYPE;) @COMPONENTSCAN( @RETENTION(RETENTIONPOLICY.RUNTIME) EXCLUDEFILTERS:{@FILTER( @DOCUMENTED TYPE FILTERTYPE.CUSTOM, CLASSES : {TYPEEXCLUDEFILTER.CLASS} @INHERITED ),@FILTER( @AUTOCONFIGURATIONPACKAGE TYPE FILTERTYPE.CUSTOM, CLASSES 三{AUTOCONFIGURATIONEXCLUDEFILTER.CLASS] QIMPORT(LAUTOCONFIGURATIONIMPORTSELECTOR.CLASS] @INTERFACE ENABLEAUTOCONFIGURATION { PUBLIC @CONFIQURATION 是一个配置类 PROXYBEANMETHODS  FALSE # A ORG @CONDITIONALONCLASS({REDISOPERATIONS.CLASS)判断是否有对应字节码 IN MAVEN:ORG.SPRINGFRAMEWORK.BOOT:SPRING-BOOT-AUTOCONFIGURE:2.9.REL ORG @ENABLECONFIGURATIONPROPERTIES((REDISPROPERTIES.CLASSH) ORS SPRING-BOOT-AUTOCONFIGURE-2.3.9.RELEASE,JAR LIBRARY ROOT LDIMPORT(FLETTUCECONNECTIONCONFIGURATION.CLASS, JEDISCONNECTIONCONFIGURATION.CLASSF) ORG PUBLIC CLASS REDISAUTOCONFIGURATION { META-INF PUBLIC REDISAUTOCONFIGURATION() ( ORG ADDITIONAL-SPRING-CONFIGURATION-METADATA.JSON ORG ORG LICENSE.TXT ORG @BEAN ORG MANIFEST.MF @CONDITIONALONMISSINGBEAN( 判断环境中没有对应的BEAN ORG NAME {'REDISTEMPLATE"] NOTICE.TXT ORG ORG SPRING.FACTORIES PUBLIC REDISTEMPLATE<OBJECT, OBJECT> REDISTEMPLATE(REDISCONNECTIONFACTORY REDISC ORG REDISTEMPLATE<OBJECT, OBJECT> TEMPLATE - NEW REDISTEMPLATEO); ORG SPRING-AUTOCONFIGURE-METADATA.PROPERTIES TEMPLATE.SETCONNECTIONFACTORY(REDISCONNECTIONFACTORY); ORG SPRING-CONFIGURATION-METADATA.JSON RETURN TEMPLATE; ORG ORG ORG.SPRINGFRAMEWORK.BOOT.AUTOCONFIGURE -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689509720557-70c9731f-fdb6-4f16-b41a-712539d48b79.png)

1.在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：

@SpringBootConfiguration、@ComponentScan、@EnableAutoConfiguration

2.@EnableAutoConfiguration是实现自动化配置的核心注解。 该注解通过@Import注解导入对应的配置选择器。读取该项目classpath路径下META-INF/spring.factories文件中的所配置的类的全类名。 （/ˈmɛtə/）

3.在这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否需要将其导入到Spring容器中。

## 9.Spring框架常见注解
Spring：

<!-- 这是一张图片，ocr 内容为：使用在类上用于实例化BEAN @CONTROLLER,@SERVICE,@REPOSITORY @COMPONENT,@CON 使用在字段上用于根据类型依赖注入 @AUTOWIRED 结合@AUTOWIRED一起使用用于根据名称进行依赖注入 QUALIFIER 标注BEAN的作用范围 @SCOPE 指定当前类是一个SPRING配置类,当创建容器时会从该类上加载注解 @CONFIGURATION 用于指定SPRING  在初始化容器时要扫描的包 @COMPONENTSCAN 使用在方法上,标注将该方法的返回值存储到SPRING容器中 @BEAN 使用@LMPORT导入的类会被SPRING加载到IOC容器中 @LMPORT 用于切面编程(AOP) @ASPECT,@BEFORE,@AFTER,@AROUND,@POINTCUT -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689509887545-b043e718-d84c-4641-893b-1300e4170b3d.png)

SpringMVC：

<!-- 这是一张图片，ocr 内容为：用于映射请求路径,可以定义在类上和方法上.用于类上,则表示类中的所有的方法都是以该地址作为父路径 @REQUESTMAPPING 注解实现接收HTTP请求的ISON数据,将ISON转换为JAVA对象 @ REQUESTBODY 指定请求参数的名称 @REGUESTPARAM 从请求路径下中获取请求参数(/USER//ID)),传递给方法的形式参数 @PATHVIRIABLE 注解实现将CONTROLLER方法返回对象转化为ISON对象响应给客户端 @ RESPONSEBODY 获取指定的请求头数据 REQUESTHEADER @CONTROLLER+@RESPONSEBODY @ RESTCONTROLLER -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689509917275-d708a098-654b-43c3-8158-b8e427a5ca83.png)

SpringBoot：

<!-- 这是一张图片，ocr 内容为：组合了-@CONFIGURATION注解,实现配置文件的功能 @ SPRINGBOOTCONFIGURATION 打开自动配置的功能,也可以关闭某个自动配置的选 ENABLEAUTOCONFIGURATION SPRING组件扫描 @COMPONENTSCAN -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689509988723-5f392b9c-2201-421c-bd98-5ffca6372d0d.png)

## 10.MyBatis执行流程
1.读取MyBatis配置文件mybatis-config.xml。

2.创建SqlSessionFactory会话工厂

3.创建SqlSession对象（包含了执行SQL语句的所有方法）

4.根据 Mapper 接口中的方法名和参数，找到对应的 SQL 语句并执行。

5.MyBatis 将结果映射为 Java 对象并返回。

## 11.MyBatis延迟加载
1.延迟加载：在需要用到数据时进行加载，不需要用到数据时就不加载数据

2.Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载

3.在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false，默认是关闭的

4.MyBatis的延迟加载是CGLIB实现的

## 12.Mybatis的二级缓存
作用：减少数据库的查询次数，提高系统性能。

1.一级缓存也被称为本地缓存，它是在同一个会话（SqlSession）中有效的缓存。当查询数据后，数据会被缓存在会话的内部，下次如果再次查询同样的数据，MyBatis会首先尝试从一级缓存中获取数据，而不会再次向数据库发起请求。

2。二级缓存是在不同会话之间共享的缓存。当启用了二级缓存后，查询的结果会被缓存在应用程序的范围内，不同的会话可以共享相同的缓存数据。MyBatis 二级缓存默认是关闭的，需要使用时可手动开启。

3.当某一个作用域进行了增删改操作后，该作用域下所有的缓存将被清除。

## 13. 一级缓存和二级缓存的区别
1.一级缓存是 SqlSession 级别的缓存，同一个 SqlSession 中的多次查询会共享同一个缓存。二级缓存是 Mapper 级别的缓存，同一个 Mapper 中的多次查询会共享同一个缓存。

2.一级缓存是默认开启的，不需要手动配置。二级缓存需要手动配置，需要在 Mapper.xml 文件中添加 <cache> 标签。

3.当 SqlSession 关闭时，一级缓存会被清空。当应用程序关闭时，二级缓存也会被清空。

4.一级缓存是线程私有的，不同的 SqlSession 之间的缓存数据不会互相干扰。二级缓存是线程共享的，多个 SqlSession 可以共享同一个二级缓存，需要考虑线程安全问题。

## 0—————————————————————————————
## 1.Spring
Spring是一个开源的轻量级框架，用于构建企业级Java项目，是以IOC和AOP为内核的，整合了众多的第三方框架

优势：

1.方便解耦，简化开发 

2.支持AOP编程和声明式事务

3.集成了各种优秀框架 

4.方便程序的集成测试 

## 2.IOC 
控制反转，一种设计原则和编程模式，将原本在程序中手动创建的对象，交由 Spring 框架来管理。

实现手段：

1.依赖注入：将依赖关系注入到对象中，实现了对象之间的解耦。依赖注入可以通过属性注入、Setter 方法和构造函数来完成。

2.依赖查找：通过容器提供的 API，手动查找和获取所需的依赖对象。

优点：

1.降低了代码之间的耦合度。

2.可维护性好，对象更易扩展和重用。

3.简化开发难度，节省开发时间。

## 3.@Autowired 和 @Resource 的区别是什么？(@Qualifier)
1.@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。

2.Autowired 默认的注入方式为（根据类型进行匹配），@Resource默认注入方式为 （根据名称进行匹配）。

3.当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。（Autowired 可以通过 @Qualifier 注解来显式指定名称，@Resource可以通过 name 属性来显式指定名称）

eg：

SmsService 接口有两个实现类: SmsServiceImpl1和 SmsServiceImpl2

```java
// 报错，byName 和 byType 都无法匹配到 bean
@Autowired
private SmsService smsService;
// 正确注入 SmsServiceImpl1 对象对应的 bean
@Autowired
private SmsService smsServiceImpl1;
// 正确注入  SmsServiceImpl1 对象对应的 bean
// smsServiceImpl1 就是我们上面所说的名称
@Autowired
@Qualifier(value = "smsServiceImpl1")
private SmsService smsService;
```

```java
// 报错，byName 和 byType 都无法匹配到 bean
@Resource
private SmsService smsService;
// 正确注入 SmsServiceImpl1 对象对应的 bean
@Resource
private SmsService smsServiceImpl1;
// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）
@Resource(name = "smsServiceImpl1")
private SmsService smsService;
```

## 4.AOP使用
组成：

● 目标(Target)：被通知的对象

● 代理(Proxy)：向目标对象应用通知之后创建的代理对象

● 连接点(JoinPoint)：目标对象的所属类中，定义的所有方法均为连接点

● 切入点(Pointcut)：被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）

● 通知(Advice)：增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情

● 切面(Aspect)：切入点(Pointcut)+通知(Advice)

● Weaving(织入)：将通知应用到目标对象，进而生成代理对象的过程动作

解释：

Pointcut（切点）：被增强的方法

Advice（通知）：封装增强业务逻辑的方法

Aspect（切面）：切点+通知

Weaving（织入）：将切点与通知结合的过程

## 5.AOP 的底层实现：
AOP 是基于动态代理的。

常用的动态代理技术

● JDK 代理 : 基于接口的动态代理技术

● cglib 代理：基于父类的动态代理技术

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2022/png/34358440/1669298285750-5c789e4b-433c-41ad-b846-953b46bf368c.png)

## 6.动态代理是如何实现的？
## 7.JDK动态代理和CGLIB有什么区别？
1.JDK 动态代理基于接口，CGLIB 动态代理基于父类。

2.JDK 动态代理实现简单，但只能代理实现了接口的类；CGLIB实现相对复杂，可以代理所有类

3.JDK 动态代理性能相对较高，生成代理对象速度较快；CGLIB 动态代理性能相对较低，生成代理对象速度较慢。

4.CGLIB 动态代理无法代理 final 类和 final 方法；JDK 动态代理可以代理任意类。

## 8.Bean有几种作用域？
1.singleton（单例）： 是 Spring 中默认的 Bean 作用域，它表示在整个应用程序中只存在一个 Bean 实例。每次请求该 Bean 时，都会返回同一个实例。

2.prototype（原型）：表示每次请求该 Bean 时都会创建一个新的实例。每个实例都有自己的属性值和状态，因此它们之间是相互独立的。（/ˈprəʊtətaɪp）

3.request（请求）：表示在一次 HTTP 请求中只存在一个 Bean 实例。在同一个请求中，多次请求该 Bean 时都会返回同一个实例。不同的请求之间，该 Bean 的实例是相互独立的。

4.session（会话）：表示在一个 HTTP Session 中只存在一个 Bean 实例。在同一个 Session 中，多次请求该 Bean 时都会返回同一个实例。不同的 Session 之间，该 Bean 的实例是相互独立的。

5.application： 表示在一个 ServletContext 中只存在一个 Bean 实例。该作用域只在 Spring ApplicationContext 上下文中有效。

6.websocket：表示在一个 WebSocket 中只存在一个 Bean 实例。该作用域只在 Spring ApplicationContext 上下文中有效。

## 9.Bean有几种注入方式？
[【Spring】三大依赖注入(@Autowired，Setter，构造方法)_autowired和构造器注入_你不应该热爱的博客-CSDN博客](https://blog.csdn.net/qq_63218110/article/details/130266346?ops_request_misc=&request_id=&biz_id=102&utm_term=spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E5%8F%AF%E4%BB%A5%E6%B3%A8%E5%85%A5final%E5%90%97&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-130266346.142^v93^chatgptT3_1&spm=1018.2226.3001.4187)

1.属性注入：

<!-- 这是一张图片，ocr 内容为：1/属性对象 @AUTOWIRED PRIVATE USERSERVICE USERSERVICE; -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689555902205-87484311-0928-48a2-ad91-937a08c6b786.png)

优点：实现简单、使用简单

缺点：无法注入一个不可变的对象（final 修饰的对象）、

会造成循环引用

2.Setter 注入：

<!-- 这是一张图片，ocr 内容为：PRIVATE USERSERVICE USERSERVICE; @AUTOWIRED J USERSERVICE) PUBLIC VOID SETUSERSERVICE(USERSERVICE THIS.USERSERVICE - USERSERVICE; -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689556027635-f1046553-fb9d-495f-ada7-f45872f151ba.png)

缺点：无法注入一个不可变的对象（final 修饰的对象）

3.构造方法注入：

<!-- 这是一张图片，ocr 内容为：构造方法注入 PRIVATE USERSERVICE USERSERVICE; 子 PUBLIC USERCONTROLLER(USERSERVICE USERSERVICE) THIS.USERSERVICE ICE : USERSERVICE; -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689556162977-8d2c9fd9-62ef-425b-a7ea-b7391c26f00a.png)

优点：可注入不可变对象；

   注入对象不会被修改；

   注入对象会被完全初始化；

   通用性更好

## 10.过滤器和拦截器
过滤器：使用 Servlet 3.0 提供的 @WebFilter 注解，配置过滤的 URL 规则，然后再实现 Filter 接口，重写接口中的 doFilter 方法。

拦截器：创建一个普通的拦截器，实现 HandlerInterceptor 接口，并重写接口中的相关方法。

区别：

1.过滤器是Servlet规范中定义的，依赖 Servlet容器，而拦截器来自于 Spring 框架，是 Spring 中的一个组件。

2.过滤器是基于方法回调实现的，拦截器是基于动态代理实现的。

4.过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、字符集编码设置等。拦截器主要用来实现项目中的业务判断的，比如：登录判断、权限判断、日志记录等业务。

## 11.${} 和 #{}有什么区别？
${} 和 #{} 在 MyBatis 中都是用于 SQL 参数替换的符号，它们的区别主要体现在以下几个方面：

1.功能不同：${} 是直接替换，而 #{}是预处理；

2.使用场景不同：普通参数使用 #{}，如果传递的是 SQL 命令或 SQL 关键字，需要使用 ${}，但在使用前一定要做好安全验证；

3.4安全性不同：使用 ${} 存在安全问题，如 SQL 注入，而 #{} 则不存在安全问题。

## 12.SQL注入
SQL 注入指应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在应用程序中事先定义好的查询语句的结尾上添加额外的 SQL 语句，实现非法操作，得到相应的数据信息。 

<!-- 这是一张图片，ocr 内容为：HTTP://LOCALHOST:8080/U/ISLOGIN?PWD三'OR 1-1 AND ID:'2&NAMEADMIN GET SEND AUTHORIZATION HEADERS(8) SETTINGS BODY PRE-REQUEST SCRIPTESTS COOKIES PARAMS QUERY PARAMS DESCRIPTION BULK EDIT VALUE KEY 000 OR 1-1 AND ID-2 PWD ADMIN NAME -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689561030924-b700d17e-bfc2-48d9-8911-fb0399d1c014.png)

## 13.动态 SQL
动态 SQL 是指可以根据不同的参数信息来动态拼接不确定的 SQL 叫做动态 SQL，MyBatis 动态 SQL 的主要元素有：if、choose/when/otherwise、trim、where、set、foreach 等。

```xml
<select id="findUser" parameterType="com.interview.entity.User" resultType="com.interview.entity.User">
  select * from t_user where 1=1
  <if test="id!=null">
    and id = #{id}
  </if>
  <if test="username!=null">
    and username = #{username}
  </if>
  <if test="password!=null">
    and password = #{password}
  </if>
</select>
```

## 0—————————————————————————————
## 1.SpringBoot配置文件优先级
properties（最高）>  yml  >  yaml（最低）

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1678439647111-fbb45f65-04fe-4b81-ac5c-817dd608c4fa.png)

