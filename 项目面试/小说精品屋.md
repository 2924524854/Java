### 1. SpringSecurity+JWT实现用户密码加密存储、权限认证、和跨域请求，使用RBAC权限管理模型简化权限管理。
[Spring Security单点登录解析_寒風冷度夜雨的博客-CSDN博客](https://blog.csdn.net/m0_64714024/article/details/125548908?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169122436416800184188208%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169122436416800184188208&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-125548908-null-null.142^v92^chatgptT0_1&utm_term=security%E5%8D%95%E7%82%B9%E7%99%BB%E5%85%A5&spm=1018.2226.3001.4187)

<!-- 这是一张图片，ocr 内容为：用户名 将JWT令牌保存在COOKIE或LOCALSTORAGE中 密码 用户 发送请求 S将JWT令牌保存 GATEWAY网关 用户名 在请求头中 密码 9 3 过滤器解析请求头中的JWT令牌 JWT令牌 00S登录服务器 过滤器解析成功之后 过滤器解析成功之后 过滤器解析成功之后 处理具体业务 处理具体业务 处理具体业务 验证用户登录信息 如果成功 返回一个JWT令牌 CSDN@寒风冷度夜雨 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1691224758144-d7542803-18dd-4f03-b684-9560bfeb5e08.png)

###### 1.利用token进行用户身份验证的流程：
1. 客户端使用用户名和密码请求登录

2. 服务端收到请求，验证用户名和密码

3. 验证成功后，服务端会签发一个token，再把这个token返回给客户端

4. 客户端收到token后可以把它存储起来，比如放到cookie中

5. 客户端每次向服务端请求资源时需要携带服务端签发的token，可以在cookie或者header中携带

6. 服务端收到请求，然后去验证客户端请求里面带着的token，如果验证成功，就向客户端返回请求数据

###### 2.优点：
1.简洁：JWT Token数据量小，传输速度也很快

2.支持跨域访问：cookie是无法跨域的，而token由于没有用到cookie(前提是将token放到请求头中)，所以跨域后不会存在信息丢失问题，可以实现单点登入。

3.无状态：token机制在服务端不需要存储session信息，因为token自身包含了所有登录用户的信息，所以可以减轻服务端压力，适用于分布式微服务。

###### 3.JWT结构：
JWT由3部分组成：标头(Header)、有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的3部分分别进行Base64编码后用.进行连接形成最终传输的字符串

<font style="color:rgb(77, 77, 77);">JWTString=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret)</font>

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1682347245348-33ba13b7-fba8-45d5-bd4f-82a8f8371cdd.png?x-oss-process=image%2Fresize%2Cw_1185%2Climit_0)

1.Header

JWT头是一个描述JWT元数据的JSON对象，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存

```java
{
  "alg": "HS256",
  "typ": "JWT"
}
```

2.Payload

有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择

```java
iss：发行人
exp：到期时间
sub：主题
aud：用户
nbf：在此之前不可用
iat：发布时间
jti：JWT ID用于标识该JWT
```

这些预定义的字段并不要求强制使用。除以上默认字段外，我们还可以自定义私有字段，一般会把包含用户信息的数据放到payload中，如下例：

```java
{
  "sub": "1234567890",
  "name": "Helen",
  "admin": true
}
```

请注意，默认情况下JWT是未加密的，因为只是采用base64算法，拿到JWT字符串后可以转换回原本的JSON数据，任何人都可以解读其内容，因此不要构建隐私信息字段，比如用户的密码一定不能保存到JWT中，以防止信息泄露。JWT只是适合在网络中传输一些非敏感的信息

3.Signature

签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以确保数据不会被篡改。首先，需要指定一个密钥（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用header中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名

HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret)

在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用.分隔，就构成整个JWT对象

<font style="color:rgb(77, 77, 77);">JWTString=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret)</font>

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1682347245396-8ff90233-ce2a-4ae1-9d17-2d22dd49b33b.png?x-oss-process=image%2Fresize%2Cw_1071%2Climit_0)

注意JWT每部分的作用，在服务端接收到客户端发送过来的JWT token之后：

● header和payload可以直接利用base64解码出原文，从header中获取哈希签名的算法，从payload中获取有效数据。

● signature由于使用了不可逆的加密算法，无法解码出原文，它的作用是校验token有没有被篡改。服务端获取header中的加密算法之后，利用该算法加上secretKey对header、payload进行加密，比对加密后的数据和客户端发送过来的是否一致。注意secretKey只能保存在服务端，而且对于不同的加密算法其含义有所不同，一般对于MD5类型的摘要加密算法，secretKey实际上代表的是盐值。

###### 4.JWT的种类：
● nonsecure JWT：未经过签名，不安全的JWT（<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">header</font><font style="color:rgb(77, 77, 77);">部分没有指定签名算法</font>）

```java
{
  "alg": "none",
  "typ": "JWT"
}
```

● JWS：经过签名的JWT（通常使用）

1.对称加密：secretKey指加密密钥，可以生成签名与验签

2.非对称加密：secretKey指私钥，只用来生成签名，不能用来验签(验签用的是公钥)

RSA（非对称）

● JWE：payload部分经过加密的JWT

###### 5.SpringSecurity
1.流程：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689055990871-8416cf74-4055-4078-b5d8-23121dacb304.png)

2.原理：

SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689056001328-129f1438-1365-42c4-a011-2947a4c2f122.png)

UsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。

ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。

FilterSecurityInterceptor：负责权限校验的过滤器。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689056025672-39512974-bf06-4e7a-b782-e985e650388a.png)

1.Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。

2.AuthenticationManager接口：定义了认证Authentication的方法

3.UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。

4.UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。

（英/ɔːˌθentɪˈkeɪʃn/）

3.使用：

1.添加依赖

2.添加JWT相关的工具类

3.添加实体类User

4.创建一个类实现UserDetailsService接口，重写其中的方法。使用用户名从数据库中查询用户信息；

因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。

5. 进行密码加密存储，我们要定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。

6.我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。

在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。

7.我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。使用userid去redis中获取对应的LoginUser对象，使用userid去redis中获取对应的LoginUser对象。

8.退出登入：我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。

9.我们需要先开启相关配置（@EnableGlobalMethodSecurity(prePostEnabled = true)），

使用注解设置权限，eg： @PreAuthorize("hasAuthority('test')")。

10.从RBAC权限模型中查询权限信息（根据用户id）

11.对SpringBoot配置跨域；开启SpringSecurity的跨域访问（在WebSecurityConfigurerAdapter的子类中开启）

4.注意：

SecurityContextHolder 是 Spring Security 框架中的一个核心类，用于管理安全上下文信息。安全上下文（SecurityContext）包含了关于当前用户的认证信息和权限信息。

###### 6.RBAC权限模型
RBAC（Role Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联，而不是直接将权限赋予用户。

一个用户拥有若干个角色，每个角色拥有若干个权限，这样就构成了“用户-角色-权限”的授权模型。

好处：不必每次创建用户时都进行权限分配的操作，只要分配用户相应的角色即可，而且角色的权限变更比用户的权限变更要少得多，减少频繁设置。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689056093719-11dc6a3a-ed5e-4964-b3ec-974e10e51426.png)

```xml
SELECT 
	DISTINCT m.`perms`
FROM
	sys_user_role ur
	LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`
	LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`
	LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`
WHERE
	user_id = 2
	AND r.`status` = 0
	AND m.`status` = 0
```

### 2. 小说排行榜会在每日零点更新，使用XXL-JOB分布式任务调度自动完成榜单的更新。防止任务的重复执行，提高系统处理效率。
<!-- 这是一张图片，ocr 内容为：XXL-JOB 你们项目中使用了什么分布式任务调度 首先,还是要描述当时是什么场景用了任务调度 XXL-JOB解决的问题 1.XXLJOB路由策略有哪些? 解决集群任务的重复执行问题 CRON表达式定义灵活 2. XXLJOB任务执行失败怎么解决? 定时任务失败了,重试和统计 3. 如果有大数据量的任务同时都需要执行,怎么解决? 任务量大,分片执行 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690034524330-2988b4c6-4f8f-42f4-9012-c42604dd9666.png)

<!-- 这是一张图片，ocr 内容为：XXLJOB路由策略有哪些? 任务1 基础配置 任务描述 测试任务1 执行器 示例执行器 负责人* 报警邮件 ITHEIM@163.COM ITHEIMA 第一个 调度配置 最后一个 固定速度 调度类型 1.FIRST(第一个):固定选择第一个机器; 轮询 2.LAST(最后一个):固定选择最后一个机器; 随机 任务配置 一致性HASH (轮询) 3.ROUND 运行模式 DEMOJOBHANDLER JOBHANDLER 最不经常使用 4.RANDOM(随机):随机选择在线的机器; 任务参数 最近最久未使用 5.CONSISTENT_HASH(一致性HASH):每个任务按照HA 故障转移 6.LEAST_FREQUENTLY_USED(最不经常使用):使用频 忙碌转移 高级配置 分片广播 7.LEAST_RECENTLY_USED(最近最久未使用):最久未使 子任务ID 轮询 路由策略 请输入子任务的任务ID,如存在多个则逗! 8.FAILOVER(故障转移):按照顺序依次进行心跳检测, 9.BUSYOVER(忙碌转移):按照顺序依次进行空闲检测 调度过期策略 忽略 阻塞处理策略 单机串行 10.SHARDING BROADCAST(分片广播):广播触发对应集 任务超时时间 O 失败重试次数 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690034539933-7e9b6e5f-32b4-409d-a097-ca5c93b04d5d.png)

<!-- 这是一张图片，ocr 内容为：故障转移+失败重试,查看日志分析--->邮件告警 调度日志 任务 调度时间 状态 执行器 清理 搜索 全部 全部 全部 2023-04-100:00:00-2023-04-1023:59:59 每页 条记录 10 任务调度中... 应用中心 设置 收件箱 邮箱团队版 首页 任务调度中... 通讯录 调度时间 任务ID 二写信 收信 标记为 回复全部 更多 删除 拒收 回复 登报 移动到 2023-04-1010:19:44 收件箱 ALARM JOB LOGLD-2 红润邮件 TRIGGERMSG 2023-04-10 10:17:44 待力邮件 任务触发类型:手动触发 星标联系人邮件 调度机器:172.16.17.191 执行器-注册方式:自动注册 已发送 执行器-地址列表:NULL 其他3个文件夹 路由策略:轮询 阻塞处理策略:单机串行 邮件标签 测试任务1 调度失败 任务超时时间:0 示例执行器 邮箱中心 失败重试次数:5 文件中心 邮箱附件 >>>>>>>>>>触发调度<<<<<<<<<<<< 办公工具 调度失败:执行器地址为空 PDF转换换工具 双PPT模板 家 >>>>>>>>>>>失败重试触发<<<<<<<<<<<< -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690034565277-f748d4b0-b245-4de4-8cda-bec24b34fd98.png)

<!-- 这是一张图片，ocr 内容为：如果有大数据量的任务同时都需要执行,怎么解决? 执行最集群部署时,任务路由策略选择分片广播情况下,一次任务调度将会广播触发对应莱群中所有执行一次任 务 任务项 分片参数 取模 INDEX:当前分片序号(从0开始),执行器集群列表中当前执行器的序号; 1 分片0 TOTAL:总分片数,执行器集群的总机器数量; @XXLJOB("SHADINGSAMPLE") 3 PUBLIC VOID SHARDINGJOBHANDLER() THROWS EXCEPTION 11分片参数 分片1 4 XXLJOBHELPER.GETSHARDINDEX(); INT SHARDINDEX INT SHARDTOTAL XX1JOBHELPER.GETSHARDTOTAL(); (数:当前分片序号:{},总分片数 :{}",SHARDINDEX, SHARDTOTAL); XX1JOBHELPER.LOG("分片参数: 5 1/业务逻辑 LIST<INTEGER> LIST - GETLIST(); 9 FOR ( (INTEGER INTEGER :LIST){ 分片2 IF(INTEGER % SHARDTOTAL -- SHARDINDEX){ 7 SYSTEM.OUT.PRINTIN("第"+SHARDINDEX+"分片执行,执行数据为:"+INTEGER); 小 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1690034587932-aad32883-7176-4250-966b-68fd28f2c253.png)

##### 1.xxl-job路由策略有哪些？
xxl-job提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、分片广播

##### 2.xxl-job任务执行失败怎么解决？
1.路由策略选择故障转移，使用健康的实例来执行任务

2.设置重试次数

3.查看日志+邮件告警来通知相关负责人解决

##### 3.如果有大数据量的任务同时都需要执行，怎么解决？
1.让多个实例一块去执行（部署集群），路由策略分片广播

2.在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行。

##### 4.实现：
1.加入xxljob的依赖

2.在配置文件中修改调度中心的地址和token

3.创建`XxlJobConfig`配置对象

4.添加任务处理类，交给Spring容器管理，在处理方法上贴上@XxlJob注解

```java
@Component
    public class SimpleXxlJob {
        @XxlJob("demoJobHandler")
        public void demoJobHandler() throws Exception {
            System.out.println("执行定时任务,执行时间:"+new Date());
        }
    }
```

5.登录调度中心,在任务管理中新增任务。

### 3. 小说离线缓存耗时长且消耗系统资源，使用线程池来管理缓存任务，避免频繁地创建和销毁线程，提高资源下载的速度和效率。
##### 1.线程池如何启动和销毁
shutdown()：会平滑地关闭线程池。该方法将停止接受新任务，并等待已经提交的任务执行完毕。已经提交的任务会继续执行直到完成，然后线程池中的线程会被停止并销毁。

shutdownNow()：立即关闭线程池。该方法会尝试中断所有正在执行的任务，并返回等待执行的任务列表。

```java
// 向线程池提交任务
threadPool.execute(new RunnableTask());

// 关闭线程池
threadPool.shutdown();
```

下载资源

```java
import java.io.*;
import java.net.URL;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class NovelDownloader {
    private static final String NOVEL_URL = "https://example.com/novel";
    private static final int NUM_OF_THREADS = 5;

    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(NUM_OF_THREADS);

        for (int chapter = 1; chapter <= 100; chapter++) {
            String chapterUrl = NOVEL_URL + "/chapter" + chapter;
            threadPool.execute(new DownloadTask(chapterUrl, "Chapter" + chapter + ".txt"));
        }

        threadPool.shutdown();
    }

    static class DownloadTask implements Runnable {
        private final String url;
        private final String fileName;

        public DownloadTask(String url, String fileName) {
            this.url = url;
            this.fileName = fileName;
        }

        @Override
        public void run() {
            try {
                URL downloadUrl = new URL(url);
                InputStream inputStream = downloadUrl.openStream();
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));

                FileWriter writer = new FileWriter(fileName);

                String line;
                while ((line = reader.readLine()) != null) {
                    writer.write(line + "\n");
                }

                reader.close();
                writer.close();
                System.out.println("Downloaded: " + fileName);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

简易版

```java
public class NovelDownloader {
    private static final String NOVEL_URL = "test.txt";

    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        for (int chapter = 1; chapter <= 10; chapter++) {
            threadPool.execute(new DownloadTask(NOVEL_URL, "D:\\java\\useless\\" + "test" + chapter + ".txt"));
        }
        threadPool.shutdown();
    }

    static class DownloadTask implements Runnable {
        private final String url;
        private final String fileName;

        public DownloadTask(String url, String fileName) {
            this.url = url;
            this.fileName = fileName;
        }

        @Override
        public void run() {
            try {
                FileInputStream fis = new FileInputStream("test.txt");
                FileOutputStream fos = new FileOutputStream(fileName);
                byte[] bys = new byte[1024]; //1024及其整数倍
                int len;
                while ((len=fis.read(bys))!=-1) {
                    fos.write(bys);
                }
                System.out.println(Thread.currentThread().getName());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

##### 2.概念：
线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务

##### 3.好处：
1.降低资源消耗。

2.提高响应速度。

3.提高线程的可管理性。

##### 4.线程池的核心参数
Executor(/ɪɡˈzekjətə(r)/)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689232038234-4bddf25a-96d2-4e17-86b9-425305f6b417.png)

corePoolSize 核心线程数目

maximumPoolSize 最大线程数 = (核心线程+救急线程的最大数目)

keepAliveTime 空闲线程存活时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放

unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等

workQueue 阻塞队列- 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务

threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等

handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689232449957-5261fc3f-6976-4c2e-b9b8-a7dd9e3f122d.png?x-oss-process=image%2Fresize%2Cw_1575%2Climit_0)

##### 5.线程池中有哪些常见的阻塞队列
workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务

1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。

2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。

3.DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的

4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。

##### 6.线程池的种类有哪些？
1.newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待

2.newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行

3.newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程

4.newScheduledThreadPool：可以执行延迟任务的线程池，支持定时及周期性任务执行

##### 7.为什么不建议用Executors创建线程池（不推荐使用内置线程池）
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689233982691-63d50723-be9d-4b4d-9100-fd8c9f586e92.png)

##### 8.如何创建线程池？
1.通过ThreadPoolExecutor构造函数来创建（推荐）。

2.通过 Executor 框架的工具类 Executors 来创建。



### 4. 使用RabbitMQ刷新ES和Redis中的小说副本数据，通过更新队列和监听器更新小说信息，实现Elasticsearch、Redis和MySQL的数据同步。
##### 0.原理:
在 novel 分布式环境中，数据库中的小说信息可能会在多个地方保存一份副本数据。例如，为了减轻数据库压力，提高并发和系统性能的本地缓存 Caffeine 和分布式缓存 Redis、为了实现小说全文高级检索的 Elasticsearch 搜索引擎等。此时，如果小说信息发生变更，那么如何通知所有的副本数据更新呢？，不影响原先功能（其它副本数据的刷新）的同时，又能及时刷新 MongoDB 中的副本数据，实现模块间的解耦呢？

##### 1.异步通知:
● 优点：低耦合，实现难度一般

● 缺点：依赖mq的可靠性

##### 2.步骤：
●  导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD 

●  声明exchange、queue、RoutingKey 

●  在hotel-admin中的增、删、改业务中完成消息发送 

●  在hotel-demo中完成消息监听，并更新elasticsearch中数据 

●  启动并测试数据同步功能

##### [07分布式搜索引擎3](https://www.yuque.com/wuqiongkaixin/java/alyf44s0g7ahwx72#85cc6fc9)
##### 3.实现：
1.在io.github.xxyopen.novel.core.constant包下创建 AMQP 相关常量类：

```java
/**
 * AMQP 相关常量
 *
 * @author xiongxiaoyang
 * @date 2022/5/25
 */
public class AmqpConsts {

    /**
     * 小说信息改变 MQ
     * */
    public static class BookChangeMq{

        /**
         * 小说信息改变交换机
         * */
        public static final String EXCHANGE_NAME = "EXCHANGE-BOOK-CHANGE";

        /**
         * Elasticsearch book 索引更新的队列
         * */
        public static final String QUEUE_ES_UPDATE = "QUEUE-ES-BOOK-UPDATE";

        /**
         * Redis book 缓存更新的队列
         * */
        public static final String QUEUE_REDIS_UPDATE = "QUEUE-REDIS-BOOK-UPDATE";

        // ... 其它的更新队列

    }

}
```

2.在io.github.xxyopen.novel.core.config包下创建 AMQP 配置类，配置各个交换机、队列以及绑定关系：

```java
/**
 * AMQP 配置类
 *
 * @author xiongxiaoyang
 * @date 2022/5/25
 */
@Configuration
public class AmqpConfig {

    /**
     * 小说信息改变交换机
     */
    @Bean
    public FanoutExchange bookChangeExchange() {
        return new FanoutExchange(AmqpConsts.BookChangeMq.EXCHANGE_NAME);
    }

    /**
     * Elasticsearch book 索引更新队列
     */
    @Bean
    public Queue esBookUpdateQueue() {
        return new Queue(AmqpConsts.BookChangeMq.QUEUE_ES_UPDATE);
    }

    /**
     * Elasticsearch book 索引更新队列绑定到小说信息改变交换机
     */
    @Bean
    public Binding esBookUpdateQueueBinding() {
        return BindingBuilder.bind(esBookUpdateQueue()).to(bookChangeExchange());
    }

    // ... 其它的更新队列以及绑定关系

}
```

3.在io.github.xxyopen.novel.manager.mq包下创建 AMQP 消息管理类，用来发送各种 AMQP 消息：

```java
/**
 * AMQP 消息管理类
 *
 * @author xiongxiaoyang
 * @date 2022/5/25
 */
@Component
@RequiredArgsConstructor
public class AmqpMsgManager {

    private final AmqpTemplate amqpTemplate;

    @Value("${spring.amqp.enable}")
    private String enableAmqp;

    /**
     * 发送小说信息改变消息
     */
    public void sendBookChangeMsg(Long bookId) {
        if (Objects.equals(enableAmqp, CommonConsts.TRUE)) {
            sendAmqpMessage(amqpTemplate, AmqpConsts.BookChangeMq.EXCHANGE_NAME, null, bookId);
        }
    }

    private void sendAmqpMessage(AmqpTemplate amqpTemplate, String exchange, String routingKey, Object message) {
        // 如果在事务中则在事务执行完成后再发送，否则可以直接发送
        if (TransactionSynchronizationManager.isActualTransactionActive()) {
            TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {
                @Override
                public void afterCommit() {
                    amqpTemplate.convertAndSend(exchange, routingKey, message);
                }
            });
            return;
        }
        amqpTemplate.convertAndSend(exchange, routingKey, message);
    }

}

```

4.在小说信息更新后，发送 AMQP 消息：

```java
@Transactional(rollbackFor = Exception.class)
@Override
public RestResp<Void> saveBookChapter(ChapterAddReqDto dto) {
    // 1) 保存章节相关信息到小说章节表
    //  a) 查询最新章节号
    int chapterNum = 0;
    QueryWrapper<BookChapter> chapterQueryWrapper = new QueryWrapper<>();
    chapterQueryWrapper.eq(DatabaseConsts.BookChapterTable.COLUMN_BOOK_ID,dto.getBookId())
            .orderByDesc(DatabaseConsts.BookChapterTable.COLUMN_CHAPTER_NUM)
            .last(DatabaseConsts.SqlEnum.LIMIT_1.getSql());
    BookChapter bookChapter = bookChapterMapper.selectOne(chapterQueryWrapper);
    if(Objects.nonNull(bookChapter)){
        chapterNum = bookChapter.getChapterNum() + 1;
    }
    //  b) 设置章节相关信息并保存
    BookChapter newBookChapter = new BookChapter();
    newBookChapter.setBookId(dto.getBookId());
    newBookChapter.setChapterName(dto.getChapterName());
    newBookChapter.setChapterNum(chapterNum);
    newBookChapter.setWordCount(dto.getChapterContent().length());
    newBookChapter.setIsVip(dto.getIsVip());
    newBookChapter.setCreateTime(LocalDateTime.now());
    newBookChapter.setUpdateTime(LocalDateTime.now());
    bookChapterMapper.insert(newBookChapter);

    // 2) 保存章节内容到小说内容表
    BookContent bookContent = new BookContent();
    bookContent.setContent(dto.getChapterContent());
    bookContent.setChapterId(newBookChapter.getId());
    bookContent.setCreateTime(LocalDateTime.now());
    bookContent.setUpdateTime(LocalDateTime.now());
    bookContentMapper.insert(bookContent);

    // 3) 更新小说表最新章节信息和小说总字数信息
    //  a) 更新小说表关于最新章节的信息
    BookInfoRespDto bookInfo = bookInfoCacheManager.getBookInfo(dto.getBookId());
    BookInfo newBookInfo = new BookInfo();
    newBookInfo.setId(dto.getBookId());
    newBookInfo.setLastChapterId(newBookChapter.getId());
    newBookInfo.setLastChapterName(newBookChapter.getChapterName());
    newBookInfo.setLastChapterUpdateTime(LocalDateTime.now());
    newBookInfo.setWordCount(bookInfo.getWordCount() + newBookChapter.getWordCount());
    newBookChapter.setUpdateTime(LocalDateTime.now());
    bookInfoMapper.updateById(newBookInfo);
    //  b) 刷新小说信息缓存
    bookInfoCacheManager.cachePutBookInfo(dto.getBookId());
    //  c) 发送小说信息更新的 MQ 消息
    amqpMsgManager.sendBookChangeMsg(dto.getBookId());
    return RestResp.ok();
}
```

5.在io.github.xxyopen.novel.core.listener包下创建 Rabbit 队列监听器，监听各个 RabbitMQ 队列的消息并处理：

```java
/**
 * Rabbit 队列监听器
 *
 * @author xiongxiaoyang
 * @date 2022/5/25
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class RabbitQueueListener {

    private final BookInfoMapper bookInfoMapper;

    private final ElasticsearchClient esClient;

    /**
     * 监听小说信息改变的 ES 更新队列，更新最新小说信息到 ES
     * */
    @RabbitListener(queues = AmqpConsts.BookChangeMq.QUEUE_ES_UPDATE)
    @SneakyThrows
    public void updateEsBook(Long bookId) {
        BookInfo bookInfo = bookInfoMapper.selectById(bookId);
        IndexResponse response = esClient.index(i -> i
                .index(EsConsts.BookIndex.INDEX_NAME)
                .id(bookInfo.getId().toString())
                .document(EsBookDto.build(bookInfo))
        );
        log.info("Indexed with version " + response.version());
    }

    // ... 监听其它队列，刷新其它副本数据

}
```

注意：

在springboot项目中，controller或service层中需要注入多个mapper接口或者另外的service接口，这时候代码中就会有多个@AutoWired注解，使得代码看起来什么的混乱。

lombok提供了一个注解：@RequiredArgsConstructor(onConstructor =@_(@Autowired))

写在类上面可以代替@AutoWired注解，需要注意的是：在注入的时候需要用final定义，或者使用@notnull注解

### 5.使用策略模式添加新的排序策略，实现小说评论区按照时间、点赞数等多种排序方式，且方便后续扩展更多的排序，让代码解耦合，提高代码的可维护性和扩展性。


```java
import java.util.List;

public interface CommentSortStrategy {
    void sort(List<String> comments);
}
```



```java
import java.util.Collections;
import java.util.List;

public class TimeSort implements CommentSortStrategy {
    @Override
    public void sort(List<String> comments) {
        // 实现按照时间顺序排序的逻辑
        Collections.sort(comments, (comment1, comment2) -> {
            // 这里假设评论是字符串，根据评论的时间戳进行排序
            // ...
            return 0;
        });
    }
}

public class LikeCountSort implements CommentSortStrategy {
    @Override
    public void sort(List<String> comments) {
        // 实现按照点赞数排序的逻辑
        Collections.sort(comments, (comment1, comment2) -> {
            // 这里假设评论是字符串，根据评论的点赞数进行排序
            // ...
            return 0;
        });
    }
}
```



```java
import java.util.List;

public class CommentSection {
    private CommentSortStrategy commentSortStrategy;

    public CommentSection(CommentSortStrategy commentSortStrategy) {
        this.commentSortStrategy = commentSortStrategy;
    }

    public void setCommentSortStrategy(CommentSortStrategy commentSortStrategy) {
        this.commentSortStrategy = commentSortStrategy;
    }

    public void displayComments(List<String> comments) {
        commentSortStrategy.sort(comments);
        System.out.println("Sorted Comments:");
        for (String comment : comments) {
            System.out.println(comment);
        }
    }
}
```



```java
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        CommentSortStrategy timeSort = new TimeSort();
        CommentSortStrategy likeCountSort = new LikeCountSort();

        CommentSection commentSection = new CommentSection(timeSort);
        List<String> comments = Arrays.asList("Comment 3", "Comment 1", "Comment 2");
        commentSection.displayComments(comments);
        // Output: Sorted Comments:
        // Comment 1
        // Comment 2
        // Comment 3

        commentSection.setCommentSortStrategy(likeCountSort);
        List<String> commentsWithLikes = Arrays.asList("Comment A (Likes: 10)", "Comment B (Likes: 5)", "Comment C (Likes: 8)");
        commentSection.displayComments(commentsWithLikes);
        // Output: Sorted Comments:
        // Comment B (Likes: 5)
        // Comment C (Likes: 8)
        // Comment A (Likes: 10)
    }
}
```



### 
