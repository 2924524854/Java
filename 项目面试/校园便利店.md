### 1. 使用异常处理器进行全局异常捕获，定义自定义的异常。
在Spring Boot中，我们可以通过自定义异常处理器来进行全局异常捕获和处理。Spring Boot提供了@ControllerAdvice注解和@ExceptionHandler注解来实现全局异常处理。

1.创建一个自定义的异常类，例如CustomException

```java
public class CustomException extends RuntimeException {
    public CustomException(String message) {
        super(message);
    }
}
```

2.创建一个全局异常处理器类，使用@ControllerAdvice注解标记它，并在其中定义异常处理方法，使用@ExceptionHandler注解来捕获并处理异常：

```java
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.http.ResponseEntity;

@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(CustomException.class)
    public ResponseEntity<String> handleCustomException(CustomException ex) {
        // 这里是对自定义异常的处理逻辑，可以根据实际需求返回自定义的错误信息或者响应状态
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ex.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGenericException(Exception ex) {
        // 这里是对其他未处理异常的处理逻辑，可以根据实际需求返回通用的错误信息或者响应状态
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Internal Server Error");
    }
}
```

在上面的示例中，我们使用@ControllerAdvice注解标记GlobalExceptionHandler类，这样Spring Boot就会将它识别为全局异常处理器。在类中定义了两个异常处理方法，分别处理自定义的CustomException和其他未处理的Exception。在处理方法中，我们可以根据实际需求返回自定义的错误信息或者响应状态。

3.测试

```java
@RestController
public class MyController {
    @GetMapping("/hello")
    public String hello() {
        // 模拟抛出自定义异常
        if (true) {
            throw new CustomException("Custom Exception Occurred");
        }

        return "Hello, World!";
    }
}
```

##### 1.SQLIntegrityConstraintViolationException
异常原因：违反了数据库的唯一约束条件，插入数据时。具有唯一约束条件的字段值重复。

解决办法：1、删除重复的数据，保证表中的数据不重复。

                  2、将具有唯一约束性的列取消唯一约束性（不建议采纳）

（用户名设置了唯一约束，用户名要作为登陆账号，必须保证唯一。在新增用户名时要对SQLIntegrityConstraintViolationException异常进行捕获）



##### 2.DataNotFoundException
数据不存在异常：用于表示在数据库或其他数据源中未找到特定数据的情况。

（客户在查找指定所需商品时。）

##### 3.BusinessException
业务逻辑异常：用于表示业务逻辑处理出现错误的情况。

（商品已售罄异常，余额不足异常）



—————————————————————————————————————————————————





全局异常捕获 

这个全局异常捕获写在common包下

```java
package com.itheima.reggie.common;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;
import java.sql.SQLIntegrityConstraintViolationException;
 
/**
 * @author LJM
 * @create 2022/4/15
 * 全局异常处理
 */
@ControllerAdvice(annotations = {RestController.class, Controller.class}) //表示拦截哪些类型的controller注解
@ResponseBody
@Slf4j
public class GlobalExceptionHandler {
 
    /**
     * 处理SQLIntegrityConstraintViolationException异常的方法
     * @return
     */
    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)
    public R<String> exceptionHandle(SQLIntegrityConstraintViolationException exception){
        log.error(exception.getMessage()); //报错记得打日志
        if (exception.getMessage().contains("Duplicate entry")){
            //获取已经存在的用户名，这里是从报错的异常信息中获取的
            String[] split = exception.getMessage().split(" ");
            String msg = split[2] + "这个用户名已经存在";
            return R.error(msg);
        }
        return R.error("未知错误");
    }
}
```

### 2. 使用Redis做数据缓存缓存商品信息等热点数据，并在redis中缓存空值防止大量非法请求查询数据库，对数据库造成巨大压力。
[05缓存优化](https://www.yuque.com/wuqiongkaixin/java/hlngavqy89ev5enm#yIsxG)

如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

<!-- 这是一张图片，ocr 内容为：例: 一个GET请求:API/NEWS/GETBYLD/1 查REDIS REDIS查不到,查DB DB 根据ID查询文章 命中,返回结果 DB查询到结果,返回(返回之前数据存储到REDIS) 缓存穿透:查询一个不存在的数据,MYSQL查询不到数据也不会直接写入缓存,就会导致每次请求都查数据库 {KEY:1,VALUE:NULL) 解决方案一:缓存空数据,查询返回的数据为空,仍把这个空结果进行缓存 优点:简单 缺点:消耗内存,可能会发生不一致的问题 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689930574025-dd74c8f1-9d57-4edf-9109-47d831c2dc4e.png)

<!-- 这是一张图片，ocr 内容为：缓存预热时,预热布隆过滤器 查询布隆过滤器 REDIS查不到,查DB 布隆过滤中存在,查REDIS 布隆过滤器 根据ID查询文章 DB 不存在,直接返回 命中,返回结果 DB查询到结果,返回(返回之前数据存储到REDIS) 解决方案二:布隆过滤器 优点:内存占用较少,没有多余KEY 缺点:实现复杂,存在误判 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689930596883-e2c66fb3-07da-4cdf-8fa1-2ac694a1ea5c.png)

<!-- 这是一张图片，ocr 内容为：BITMAP(位图):相当于是一个以(BIT)位为单位的数组中每个单元只能存储二进制数0或1 布隆过滤器作用:布隆过滤器可以用于检索一个元素是否在一个集合中. )存储数据:ID为1的数据,通过多个HASH函数获取HASH值,根据HASH计算数组对应位置改为1 ID1 查询数据:使用相同HASH函数获取HASH值,判断对应位置是否都为1 HASH2(1)3 HASH3(1)-7 HASH1(1)-1 0 0 0 0 1 0 0 0 7 8 5 11 6 9 10 15 2 14 12 13 4 0 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689931455466-2e7a75e7-765b-475c-80e2-392f29cc9635.png)

具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

布隆过滤器可能会存在误判的情况。总结来说就是：布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在

### 3. 用户查询商品分页信息时，越往后分页查询效率越低。使用覆盖索引加子查询形式进行对SQL语句进行优化。
（介绍项目中实际用到的）products商品信息表

聚簇索引（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个

非聚簇索引（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个

覆盖索引：查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到

<!-- 这是一张图片，ocr 内容为：在数据量比较大时,如果进行LIMIT分页查询,在查询时,越往后,分页查询效率越低. 我们一起来看看执行LIMIT分页查询耗时对比: LECT * FROM TB_SKU LIMIT 0,10; MYSQL> SELECT * 10 ROWS IN SET (0.00 S SEC) TB_SKU LIMIT 9000000,10; MYSQL> SELECT * FROM (11.05 SEC) 10 ROWS IN SET 因为,当在进行分负查询时,如果执行LIMIT900000,10,此时需要MYSQL排序前900010记录,仅仅这回, 9000000-900010的记录,其他记录丢弃,查询排序的代价非常大. -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689993120311-44a96cf9-227f-4e1c-8627-575a6f8ccce5.png)

<!-- 这是一张图片，ocr 内容为：优化思路:一股分页查询时,通过创建覆盖索引能够比较好地提高性能,可以通过覆盖索引加子查询形式进行优化 SELECT FROM TB SKU T, (SELECT ID FROM TB SKU ORDER BY ID LIMIT 9000000,10) A WHERE T.ID A.ID; 10 T (7.19 SEC) (7.13 SEC) (7.37 SEC) 10 10 ROWS IN SET IN SET ROWS IN SET ROWS -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689993132773-d2023640-d739-49a9-b6ac-90e09df268e3.png)

### 4. 访问限时优惠商品详情页等资源影响数据库的性能，使用MySQL读写分离解决单台数据库访问压力过大的问题，将读写操作分散到不同的数据库节点上。
比如：

项目有大量的读操作（如商品列表、详情页面、评论区等信息），相对较少的写操作（如下单、付款、库存更新等）。通过使用读写分离，将读操作分发到从库，从而减轻主库的负载，提高了系统的性能和响应速度。

读写分离：

将对数据库的读写操作分散到不同的数据库节点上。 这样能够小幅提升写性能，大幅提升读性能。

实现：

1.部署多台数据库，选择其中的一台作为主数据库负责写数据，其他作为从数据库负责读数据。

2.保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的主从复制。

[06读写分离](https://www.yuque.com/wuqiongkaixin/java/xqqvfpy5l1sz99t6#TOXNo)

[如何使用MySQL进行主从复制_mysql主从复制_秋天的童话_的博客-CSDN博客](https://blog.csdn.net/han1725692339/article/details/125912816?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169104672216800184179726%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169104672216800184179726&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-5-125912816-null-null.142^v92^chatgptT0_1&utm_term=mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&spm=1018.2226.3001.4187)

主从复制的实现方式涉及复制日志的传播，因此会存在一定的数据同步延迟。

首先修改主库的配置文件/etc/my.cnf，开启mysql主库的二进制日志，并设置服务器唯一id重启mysql，

然后设置从库的唯一ID，将从库绑定到主库，重启数据库。

<!-- 这是一张图片，ocr 内容为：MASTER DB WRITE 数据库中 同步 应用 间件 READ SLAVE DB -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689993315550-74431c78-d017-4af7-ab15-1602f6d3e03c.png)5

<!-- 这是一张图片，ocr 内容为：MYSQL主从复制的核心就是二进制日志 二进制日志(BINLOG) 记录了所有的DDL(数据定义语言)语句和DML(数理探纵语言)语句,但不包括数据查询(SELECT.SHOW)语句. MASTER SLAVE 复制分成三步: INSERT IOTHREAD INSERT 1.MASTER主库在事务提交时,会把数据变更记录在二进制 SOLTHREAD 日志文件BINLOG中. READ 2.从库读取主库的二进制日志文件BINLOG,写入到从库的 READ DATA WRITE CHANGE REPLAY 中继日志RELAY LOG. 3.SLAVE重做中继日志中的事件,将改变反映它自己的数据. BINLOG RELAY LOG -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689993329563-25b64bf5-ffea-495d-90a6-6a212fd108f1.png)

MySQL主从复制的核心就是二进制日志binlog(DDL（数据定义语言）语句和 DML（数据操纵语言）语句)

① 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。

② 从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。

③ 从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。

### 5. 在团购时只有当所有成员都提交选购的商品才能进行支付，使用CountDownLatch同步工具来实现多线程时目标线程最后执行
CountDownLatch（闭锁/倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）

1.其中构造参数用来初始化等待计数值

2.await() 用来等待计数归零

3.countDown() 用来让计数减一

```java
public static void main(String[] args) throws InterruptedException {
        //初始化了一个倒计时锁 参数为 3
        CountDownLatch latch = new CountDownLatch(3);

        new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+"-begin...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(Thread.currentThread().getName()+"-end..." +latch.getCount());
            //count--
            latch.countDown();

        }).start();

        new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+"-begin...");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(Thread.currentThread().getName()+"-end..." +latch.getCount());
            //count--
            latch.countDown();
        }).start();

        new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+"-begin...");
            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(Thread.currentThread().getName()+"-end..." +latch.getCount());
            //count--
            latch.countDown();
        }).start();

        String name = Thread.currentThread().getName();
        System.out.println(name + "-waiting...");
        //等待其他线程完成
        latch.await();
        System.out.println(name + "-wait end...");
    }
```

### 6. 使用责任链模式来实现多种优惠活动的打折，降低耦合度增强系统的灵活性和可扩展性，可以动态地改变链内的成员或者修改他们的次序，从而实现不同的用户、不同的时间享受不同的折扣。
责任链模式：将多个处理对象连成一条责任链，依次处理请求，直到请求被处理或到达责任链的末尾。

<!-- 这是一张图片，ocr 内容为：FILTER2 控制层 FILTER1 FILTER3 DOFILTER() DOFILTER() DOFILTER() 目标方法 -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689994083623-1acfd64a-a7c0-44b9-8d41-a0586b7db30a.png)

<!-- 这是一张图片，ocr 内容为：(ABSTRACT)HANDLER ORDERLNFO 处理订单的操作 +HANDLER.HANDLER PRODUCTLD:STRING CLIENT USERLD:STRING -AMOUNT:BIGDECIMAL +SETNEXT(HANDLER):VOID 检验参数 +HANDLER(ORDERLNFO):VOID + SETTER/GETTER 创建执行链 填充订单数据 算价 落库 ORDERCREATE ORDERVALIDITION ORDERAMOUNTCALCUATE ORDERFILL +HANDLER:HANDLER +HANDLER:HANDLER +HANDLER:HANDLER HANDLER:HANDLER +SETNEXT(HANDLER):VOID +SETNEXT(HANDLER):VOID +SETNEXT(HANDLER):VOID +SETNEXT(HANDLER):VOID +HANDLER(ORDERLNFO):VOID +HANDLER(ORDERLNFO):VOID +HANDLER(ORDERLNFO):YOID +HANDLER(ORDERLNFO):VOID -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1689994149921-9b98f8ae-363b-46a6-b00f-27afbac40227.png)

优点：

1.降低了对象之间的耦合度

2.增强了系统的可扩展性

3.增强了给对象指派职责的灵活性

4.责任链简化了对象之间的连接

5.责任分担

缺点：

1.性能问题： 如果责任链过长，可能会导致性能问题，因为每个处理者都要依次处理请求。

2.可能导致请求未被处理： 如果责任链中没有适当的处理者来处理请求，请求可能不会被正确处理。

抽象处理者：

```java
public abstract class Handler {
    protected Handler handler;
    public void setNext(Handler handler) {
        this.handler = handler;
    }

    public abstract void process();
}
```

启动类：

```java
public class Test {
    public static void main(String[] args) throws Exception {
        Plan1 plan1 = new Plan1();
        Plan2 plan2 = new Plan2();
        Plan3 plan3 = new Plan3();

        plan1.setNext(plan2);
        plan2.setNext(plan3);
        plan1.process();
    }
}
```

实现：

```java
public class Plan1 extends Handler{
    @Override
    public void process() {
        System.out.println("plan1");
        handler.process();
    }
}

/**
 *---------------------------------------------------------------------------------
 */
public class Plan2 extends Handler{
    @Override
    public void process() {
        System.out.println("plan2");
        handler.process();
    }
}

/**
 * 计算金额
 *----------------------------------------------------------------------------------
 */
public class Plan3 extends Handler{
    @Override
    public void process() {
        System.out.println("plan3");
    }
}
```

责任链模式可以用于实现商品打折的场景，其中不同的处理者可以根据商品的条件来决定是否给予折扣以及折扣的金额。



相关优惠：每周三：六折。周年庆：满100减30

eg：

使用策略模式实现多重打折

```java
// 多重打折策略，可以叠加应用多个策略
class CompositeDiscountStrategy implements DiscountStrategy {
    private List<DiscountStrategy> strategies;

    public CompositeDiscountStrategy() {
        strategies = new ArrayList<>();
    }

    public void addStrategy(DiscountStrategy strategy) {
        strategies.add(strategy);
    }

    @Override
    public double applyDiscount(double originalPrice) {
        for (DiscountStrategy strategy : strategies) {
            originalPrice = strategy.applyDiscount(originalPrice);
        }
        return originalPrice;
    }
}
```

解决方法：

1.增加一个新的策略：无法对代码进行复用，增加了代码量。

2.同时使用多个策略：客户端需要显式地选择使用哪个策略，可能需要了解所有可用的策略。会给编码带来困难。



可以动态地改变链内的成员或者修改他们的次序：

可以修改责任链的顺序，先打折后再参加满减的，而且需要打折后的金额达到满减的门槛要求，才能使用满减券。















































































## 0__________________________________________________________________
### 1. Mybatis Plus公共字段自动填充,统一对创建时间、创建人、修改时间这些字段进行处理，避免重复代码。
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2023/png/34358440/1673340552474-3c18d550-8b70-41ba-a630-d8eecb17a269.png?x-oss-process=image%2Fresize%2Cw_1378%2Climit_0)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2022/png/34358440/1671007792824-865c56ba-fa14-42e5-8cbf-f89344433d97.png?x-oss-process=image%2Fresize%2Cw_1196%2Climit_0)

```java
把相关的注解加在需要mybatis-plus自动帮我们填充的字段上面
    
    @TableField(fill = FieldFill.INSERT) //插入时填充字段
    private LocalDateTime createTime;
 
    @TableField(fill = FieldFill.INSERT_UPDATE) //插入和更新时填充字段
    private LocalDateTime updateTime;
 
    @TableField(fill = FieldFill.INSERT) //插入时填充字段
    private Long createUser;
 
    @TableField(fill = FieldFill.INSERT_UPDATE) //插入和更新时填充字段
    private Long updateUser;
```

<font style="color:rgb(77, 77, 77);">然后设置一个处理类：在此类中为公共字段赋值，需要实现 接口；</font>

```java
package com.itheima.reggie.common;
 
import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.reflection.MetaObject;
 
import java.time.LocalDateTime;
 
/**
 * @author LJM
 * @create 2022/4/16
 * 自定义元数据对象处理器
 */
@Slf4j
@Component   //注意:这个要记得交给spring容器管理，不然这个功能就没发用。。。。
//那么怎么确定你要添加的功能是不是要交给容器管理呢？就是你直接写了一个工具类或者是功能类，需要对数据库的数据或者是数据库数据的结果产生影响的时候，你明明写了这样一个类，但是功能却没有生效，那么这个时候就要首先考虑是不是容器没有托管这个类
public class MyMetaObjecthandler implements MetaObjectHandler {
 
    /**
     * 插入操作，自动填充
     * @param metaObject
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime",LocalDateTime.now());
        
        metaObject.setValue("createUser", new Long(1));  //这里的id是不能直接获取的，所以这里先写死，后面教你怎么动态获取员工id
        metaObject.setValue("updateUser",new Long(1));
    }
 
    /**
     * 更新操作，自动填充
     * @param metaObject
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        metaObject.setValue("updateTime",LocalDateTime.now());
        metaObject.setValue("updateUser",new Long(1));
    }
}
```

**<font style="color:rgb(77, 77, 77);">功能完善：</font>**

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2022/png/34358440/1671007793037-c622af59-c0c2-478f-92a6-6b1a727b0d35.png?x-oss-process=image%2Fresize%2Cw_1152%2Climit_0)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2022/png/34358440/1671007794373-77ffb1cd-d6b7-4029-a544-47ec14c76401.png?x-oss-process=image%2Fresize%2Cw_1132%2Climit_0)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2022/png/34358440/1671007794151-17b81360-1b5f-4aeb-b70f-47306baf2614.png?x-oss-process=image%2Fresize%2Cw_1192%2Climit_0)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2022/png/34358440/1671007794195-812b11ae-ec0e-47fc-bd4f-80c8776a1020.png?x-oss-process=image%2Fresize%2Cw_1156%2Climit_0)

<font style="color:rgb(77, 77, 77);">然后</font>**<font style="color:rgb(77, 77, 77);">为了动态的获取员工的id</font>**<font style="color:rgb(77, 77, 77);">,这里我们使用了threadLocal这个局部变量来获取和存储员工id;</font>

<font style="color:rgb(77, 77, 77);">创建一个工具类来设置和获取threadLocal中的员工id, </font>**<font style="color:rgb(77, 77, 77);">注意：要先把数据设置进threadLocal中，才能获取到</font>**

```java
package com.itheima.reggie.common;
 
/**
 * @author LJM
 * @create 2022/4/16
 *  基于ThreadLocal封装工具类，用户保存和获取当前登录用户id
 */
public class BaseContext {
    //用来存储用户id
    private static ThreadLocal<Long> threadLocal = new ThreadLocal<>();
 
    /**
     * 设置值
     * @param id
     */
    public static void setCurrentId(Long id){
        threadLocal.set(id);
    }
 
    /**
     * 获取值
     * @return
     */
    public static Long getCurrentId(){
        return threadLocal.get();
    }
}
```

<font style="color:rgb(77, 77, 77);">在前面我们写的LongCheckFilter这个过滤器中，把这个地方的代码加上添加和保存id的代码</font>

```java
//4、判断登录状态，如果已登录，则直接放行
if(request.getSession().getAttribute("employee") != null){
    //log.info("用户已登录，用户id为：{}",request.getSession().getAttribute("employee"));
    //把用户id存储到本地的threadLocal
    Long emId = (Long) request.getSession().getAttribute("employee");
    BaseContext.setCurrentId(emId);

    filterChain.doFilter(request,response);
    return;
}
```

```java
把处理器中的静态id改为动态获取：
metaObject.setValue("createUser", BaseContext.getCurrentId());
metaObject.setValue("updateUser",BaseContext.getCurrentId());
```



### 2. 通过ThreadLocal保存用户信息，请求的线程内可以随时获得用户信息，进行线程隔离，线程结束前，移除value,防止内存泄漏问题的发生。


















































